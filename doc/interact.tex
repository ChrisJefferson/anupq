%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  interact.tex    ANUPQ documentation - interactive f'ns      Werner Nickel
%A                                                                Greg Gamble
%%
%A  @(#)$Id$
%%
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Interactive ANUPQ functions}

Here we describe the interactive functions defined by the {\ANUPQ}  share
package, i.e.~the functions  that  manipulate  and  initiate  interactive
{\ANUPQ} processes.

An  interactive  {\ANUPQ}  process  is  initiated  by   `PqStart'   and
terminated  via  `PqQuit';   these   functions   are   described   in
Section~"Starting and Stopping Interactive ANUPQ Processes".

Each interactive {\ANUPQ} function that manipulates  an  already  started
interactive {\ANUPQ} process, has a form where the first argument is  the
integer <i> returned by the initiating `PqStart' command,  and  a  second
form with one argument fewer (where the integer <i> is  discovered  by  a
default mechanism, namely by determining the least integer <i> for  which
there is a currently active interactive {\ANUPQ} process). We  will  thus
commonly say that  ``for  the  <i>th  (or  default)  interactive  {ANUPQ}
process'' a certain function performs a given action. In each case, it is
an error, if <i> is not the index of an active  interactive  process,  or
there are no current active interactive processes.

*Notes*: 
The global method of passing options (via `PushOptions'), should  not  be
used with any of the interactive functions. In fact,  the  `OptionsStack'
should be empty at the time any of the interactive functions is called.

On `quit'ting {\GAP}, `PqQuitAll();' is executed,  which  terminates  all
active interactive  {\ANUPQ}  processes.  If  {\GAP}  is  killed  without
`quit'ting, before all interactive  {\ANUPQ}  processes  are  terminated,
*zombie* processes (still living *child* processes whose  *parents*  have
died), will result. Since zombie processes do consume resources, in  such
an event, the responsible computer user should  seek  out  and  kill  the
still living `pq' children (e.g.~by piping the  output  of  a  `ps'  with
appropriate options, usually `aux' or `ef', to `grep  pq',  to  find  the
process ids, and then using `kill'; try `man ps' and `man kill' if  these
hints are unhelpful).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Starting and Stopping Interactive ANUPQ Processes}

\>PqStart( <G>, <workspace> ) F
\>PqStart( <G> ) F

activates an iostream for an interactive {\ANUPQ} process, i.e. it starts
up the `pq' binary and opens an iostream to ``talk'' to it;  and  returns
an integer <i> that can be used to  identify  that  process.  The  record
`ANUPQData.io[<i>]' stores information that is important for the  process
(see~"ANUPQData"). The argument <G> should be an *fp group* that the user
intends to manipute using interactive {\ANUPQ} functions. If `PqStart' is
given a second argument <workspace> then the `pq' binary  is  started  up
with a workspace (an integer array) of size <workspace> (i.e.  $4  \times
<workspace>$ bytes in a 32-bit environment); otherwise, the  `pq'  binary
sets a default workspace of $10000000$.

\>PqQuit( <i> ) F
\>PqQuit() F

closes the stream of the <i>th or default  interactive  {\ANUPQ}  process
and unbinds its `ANUPQData.io' record.

*Note:*
It can happen that the `pq' binary process, and hence the {\GAP} iostream
assigned to communicate with it, can  die,  e.g.~by  the  user  typing  a
`Ctrl-C' while the `pq' binary process is engaged in a long  calculation.
`IsPqProcessAlive' (see~"IsPqProcessAlive")  is  provided  to  check  the
status of the {\GAP} iostream (and hence the status of  the  `pq'  binary
process it was communicating with).

\>PqQuitAll() F

is provided  as  a  convenience,  to  terminate  all  active  interactive
{\ANUPQ} processes with a single command. It is equivalent  to  executing
`PqQuit(<i>)'  for  all  active  interactive   {\ANUPQ}   processes   <i>
(see~"PqQuit").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Interactive ANUPQ Process Utility Functions and Interruption of
an Interactive ANUPQ Process}

\>PqProcessIndex( <i> ) F
\>PqProcessIndex() F

With argument <i>, which must be  a  positive  integer,  `PqProcessIndex'
returns <i> if it corresponds to an active interactive process, or raises
an error. With no arguments it returns  the  default  active  interactive
process or returns `fail' and  emits  a  warning  message  to  `Info'  at
`InfoANUPQ' or `InfoWarning' level 1.

*Note:*
Essentially,  an  interactive  {\ANUPQ}  process  <i>  is  ``active''  if
`ANUPQData.io[<i>]' is bound (i.e.~we still have  some  data  telling  us
about it). Also see~"PqStart".

\>PqProcessIndices() F

returns the list of integer indices of all  active  interactive  {\ANUPQ}
processes (see~"PqProcessIndex" for the meaning of ``active'').

\>IsPqProcessAlive( <i> ) F
\>IsPqProcessAlive() F

return  `true'  if  the  {\GAP}  iostream  of  the  <i>th  (or   default)
interactive {\ANUPQ} process started  by  `PqStart'  is  alive  (i.e.~can
still be written to), or `false', otherwise. (See the notes for~"PqStart"
and~"PqQuit".)

\atindex{interruption}{@interruption of an interactive ANUPQ process}
If the user does not yet have a  `gap>'  prompt  then  usually  the  `pq'
binary is still away doing something and an {\ANUPQ}  interface  function
is still waiting for a reply. Typing a `Ctrl-C'  (i.e.~holding  down  the
`Ctrl' key and typing `c') will stop the waiting and send {\GAP}  into  a
`break'-loop, from which one has no option but to `quit;'. The typing  of
`Ctrl-C', in such a  circumstance,  usually  causes  the  stream  of  the
interactive  {\ANUPQ}  process  to  die;  to  check   this   we   provide
`IsPqProcessAlive' (see~"IsPqProcessAlive").

The {\GAP} iostream of an interactive {\ANUPQ} process will also  die  if
the {\ANUPQ} binary has a segmentation fault. We do hope that this  never
happens to you, but if it does and the failure is reproducible, then it's
a bug and we'd like to know about it. Please read the `README' that comes
with the {\ANUPQ} share package to find out what  to  include  in  a  bug
report and who to email it to.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Interactive ANUPQ Functions based on menu items of the pq binary}

The `pq' binary has 5 menus, the details of which  the  reader  will  not
normally need to know, but if she wishes to know the details they may  be
found in the standalone manual: `guide.dvi'.  Both  `guide.dvi'  and  the
`pq' binary refer to the items of these 5 menus as ``options'', which  do
*not* correspond in any way to the options used  by  any  of  the  {\GAP}
functions that interface with the `pq' binary.

\>PqPcPresentation( <i> : <options> ) F
\>PqPcPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> for the group of  that  process  so  that  the  `pq'  binary
computes a pc presentation, where the group of a process is the one given
as first argument when `PqStart' was called to initiate that process (for
process <i> the group is stored as `ANUPQData.io[<i>].group').

*Note:* For those  familiar  with  the  `pq'  binary,  `PqPcPresentation'
performs option 1 of the main $p$-Quotient menu.

\>PqWritePcPresentation( <i>, <outfile> ) F
\>PqWritePcPresentation( <outfile> ) F

for the <i>th or default interactive {\ANUPQ}  process,  tells  the  `pq'
binary to write a pc presentation to <outfile>  for  the  group  of  that
process for which a pc presentation has been previously  computed,  where
the group of a process is the one given as first argument when  `PqStart'
was called to initiate that process (for process <i> the group is  stored
as  `ANUPQData.io[<i>].group').  If  a  pc  presentation  has  not   been
previously computed by the `pq' binary, then `pq' is called to compute it
first, effectively invoking `PqPcPresentation' (see~"PqPcPresentation").

*Note:* For those familiar with the `pq' binary,  `PqPcWritePresentation'
performs option 25 of the interactive $p$-Quotient menu.

\>PqSPPcPresentation( <i> : <options> ) F
\>PqSPPcPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> for the group of  that  process  so  that  the  `pq'  binary
computes a pc presentation, where the group of a process is the one given
as first argument when `PqStart' was called to initiate that process (for
process <i> the group is stored as `ANUPQData.io[<i>].group').

*Note:* For those familiar with  the  `pq'  binary,  `PqSPPcPresentation'
performs option 1 of the Standard Presentation menu.

\>PqSPStandardPresentation( <i> : <options> ) F
\>PqSPStandardPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> to compute a standard presentation for  the  group  of  that
process and a previously computed $p$-quotient of the  group,  where  the
group of a process is the one given as first argument when `PqStart'  was
called to initiate that process (for process <i> the group is  stored  as
`ANUPQData.io[<i>].group'   and   the   $p$-quotient   is    stored    as
`ANUPQData.io[<i>].pQuotient'). If a $p$-quotient of the  group  has  not
been previously computed a class 1 $p$-quotient is computed.

*Note:* For those familiar with  the  `pq'  binary,  `PqSPPcPresentation'
performs option 2 of the Standard Presentation menu.

\>PqSPIsomorphism( <i> ) F
\>PqSPIsomorphism() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute the isomorphism from the generators of the automorphism
group of `ANUPQData.io[<i>].pQuotient' to the generators for the standard
presentation.

*Note:* For  those  familiar  with  the  `pq'  binary,  `PqSPIsomorphism'
performs option 8 of the Standard Presentation menu.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Interactive Versions of Non-interactive ANUPQ Functions}

\>Pq( <i> : <options> )!{interactive} F
\>Pq( : <options> )!{interactive} F

returns for the finitely presented group <F>, of  the  <i>th  or  default
interactive {\ANUPQ}  process,  the  $p$-quotient  of  <F>  specified  by
<options>, as a pc-group. The group <F>  is  the  group  given  as  first
argument  to  `PqStart'  to  start  the  interactive   {\ANUPQ}   process
(see~"PqStart"). Behind the colon <options> a selection  of  the  options
listed for the non-interactive `Pq' function (see~"Pq") should be  given,
separated by commas like record components (see~"ref:function  call  with
options"),  except   that   the   options   `SetupFile',   `Verbose'   or
`PqWorkspace' are ignored by the interactive `Pq'. A pc  presentation  is
only computed if one has not previously been computed  and  none  of  the
options given in the call differ from previous values.

*Note:*
If a pc  presentation  has  previously  been  computed  any  options  not
supplied are assumed to have  the  values  of  the  previous  call  to  a
function that computed a pc presentation, i.e.~it is  ok  to  provide  no
options if a pc presentation has already been computed. Take care though,
if on a previous function call that computed a pc  presentation  you  set
`Metabelian', for example, but on a subsequent  call  to  `Pq'  you  wish
`Metabelian' to be `false', then you must explicitly set  `Metabelian  :=
false' in the `Pq' call (the usual default of `false' is  over-ridden  by
the previous value provided), or alternatively  call  `PqPcPresentation',
which never avoids re-doing the computation, with your intended options.

The following is one of the examples for the non-interactive `Pq'  redone
with the interactive version:

\beginexample
gap> F := FreeGroup("a", "b");; a := F.1;; b := F.2;;
gap> G := F / [a^4, b^4];         
<fp group on the generators [ a, b ]>
gap> PqStart(G);     
1
gap> SetInfoLevel(InfoANUPQ, 3); # To see behind the scenes
gap> Pq(: Prime := 2, ClassBound := 3 );
#I  ToPQ> 7  #to (Main) p-Quotient Menu
#I  Select option: 
#I  ToPQ> 1  #define group
#I  ToPQ> prime 2
#I  ToPQ> class 3
#I  ToPQ> exponent 0
#I  ToPQ> output 1
#I  ToPQ> generators { a,b }
#I  ToPQ> relations  { a^4,b^4 };
#I  
#I  Lower exponent-2 central series for G
#I  
#I  Group: G to lower exponent-2 central class 1 has order 2^2
#I  
#I  Group: G to lower exponent-2 central class 2 has order 2^5
#I  
#I  Group: G to lower exponent-2 central class 3 has order 2^8
#I  Computation of presentation took 0.00 seconds
#I  
#I  Select option: 
#I  ToPQ> 8  #to Interactive p-Quotient Menu
#I  Select option: 
#I  ToPQ> 25 #set output file
#I  Enter output file name: 
#I  ToPQ> /tmp/fileEHbOqq.2/PQ_OUTPUT
#I  Output file in CAYLEY (1) or GAP (2) or Magma (3) format? 
#I  ToPQ> 2  #output in GAP format
#I  Group presentation written in GAP format to file
#I  
#I  Select option: 
<pc group of size 256 with 8 generators>
\endexample

\>PqEpimorphism( <i> : <options> )!{interactive} F
\>PqEpimorphism( : <options> )!{interactive} F

returns for the finitely presented group <F>, of  the  <i>th  or  default
interactive  {\ANUPQ}  process,  an  epimorphism  from   <F>   onto   the
$p$-quotient of <F> specified by <options>. The group <F>  is  the  group
listed as first argument to `PqStart' to start the  interactive  {\ANUPQ}
process (see~"PqStart"). Behind the colon <options> a  selection  of  the
options given for the non-interactive `Pq' function (see~"Pq") should  be
given, separated by commas like record components (see~"ref:function call
with  options"),  except  that  the  options  `SetupFile',  `Verbose'  or
`PqWorkspace' are ignored by the interactive `PqEpimorphism' function.

\index{automorphisms!of p groups}
\>PqStandardPresentation( <i>, <p> : <options> )!{interactive} F
\>PqStandardPresentation( <p> : <options> )!{interactive} F
\>PqStandardPresentation( <i>, <G> : <options> )!{interactive} F
\>PqStandardPresentation( <G> : <options> )!{interactive} F
\>StandardPresentation( <i>, <p> : <options> )!{interactive} M
\>StandardPresentation( <p> : <options> )!{interactive} M
\>StandardPresentation( <i>, <G> : <options> )!{interactive} M
\>StandardPresentation( <G> : <options> )!{interactive} M

return, for the finitely presented group <F>  of  the  <i>th  or  default
interactive  {\ANUPQ}  process,  the  standard   presentation   for   the
$p$-quotient of <F> specified by the <p> or <G> argument  and  <options>,
as a pc group. The group <F> is the group  given  as  first  argument  to
`PqStart' to start  the  interactive  {\ANUPQ}  process  (see~"PqStart").
Behind the colon <options> a selection  of  the  options  given  for  the
non-interactive             `PqStandardPresentation'             function
(see~"PqStandardPresentation") should be given, separated by commas  like
record components (see~"ref:function call with options"), except that the
options `SetupFile',  `Verbose'  or  `PqWorkspace'  are  ignored  by  the
interactive    `PqStandardPresentation'    and     `StandardPresentation'
functions.

If the  user  supplies  a  prime  <p>  then  `PqStandardPresentation'  or
`StandardPresentation' computes a $p$-quotient of <F> for the prime <p>.

Alternatively, a user may supply a pc group <G> which is  a  $p$-quotient
of <F>, and if she does so, the automorphism group of <G> must be  known.
The presentation for <G> can be constructed by an initial  call  to  `Pq'
(see "Pq"). For <G> one usually chooses a class 1  $p$-quotient  of  <F>,
since the automorphism group of <G>  must  be  known  and  this  is  most
readily available when <G> is an  elementary  abelian  group.  Where  the
necessary information is available for a $p$-quotient  of  higher  class,
one can  apply  the  standard  presentation  algorithm  from  that  class
onwards.

Taking  one  of  the  examples  for  the   non-interactive   version   of
`StandardPresentation'  (see~"StandardPresentation")  that  required  two
separate calls to the `pq' binary, we now show that with the  interactive
version of `StandardPresentation' how it can be  done  by  setting  up  a
dialogue with just the one `pq' process:

\beginexample
gap> F4 := FreeGroup( "a", "b", "c", "d" );;
gap> a := F4.1;; b := F4.2;; c := F4.3;; d := F4.4;;
gap> G4 := F4 / [ b^4, b^2 / Comm(Comm (b, a), a), d^16,
>                 a^16 / (c * d), b^8 / (d * c^4) ];
<fp group on the generators [ a, b, c, d ]>
gap> PqStart(G4); #Start a new interactive process for a new group
2
gap> SetInfoLevel(InfoANUPQ, 1); #Only essential Info please
gap> K := Pq( 2 : Prime := 2, ClassBound := 1 ); #`pq' process no. is 2
<pc group of size 4 with 2 generators>
gap> AutomorphismGroup( K );     #Make sure Aut. group is known
<group with 4 generators>
gap> StandardPresentation( 2, K : ClassBound := 14, PcgsAutomorphisms );
<fp group with 53 generators>
\endexample

\>EpimorphismPqStandardPresentation( <i>, <p> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <p> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <i>, <G> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <G> : <options> )!{interactive} F
\>EpimorphismStandardPresentation( <i>, <p> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <p> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <i>, <G> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <G> : <options> )!{interactive} M

Each of the above functions accepts the same arguments and options as the
function `StandardPresentation' (see~"StandardPresentation") and  returns
an epimorphism from the finitely presented group  <F>  of  the  <i>th  or
default interactive {\ANUPQ} process onto the  finitely  presented  group
given  by  a  standard  presentation,  i.e.~if  <S>   is   the   standard
presentation   computed   for   <F>   by   `StandardPresentation'    then
`EpimorphismStandardPresentation' returns the epimorphism from <F> to the
group with presentation <S>. The group <F> is the group  given  as  first
argument  to  `PqStart'  to  start  the  interactive   {\ANUPQ}   process
(see~"PqStart").

%Taking        our         earlier         non-interactive         example
%(see~"EpimorphismPqStandardPresentation")   we   again   illustrate   how
%something thta required two separate calls to the `pq' binary can now  be
%achieved with a dialogue with just one `pq' process.

%\beginexample
%gap> F := FreeGroup (6);;
%gap> x := F.1;; y := F.2;; z := F.3;; w := F.4;; a := F.5;; b := F.6;;
%gap> R := [x^3 / w, y^3 / w * a^2 * b^2, w^3 / b,
%>          Comm (y, x) / z, Comm (z, x), Comm (z, y) / a, z^3 ];;
%gap> Q := F / R;;
%gap> G := Pq ( Q : Prime := 3, ClassBound := 3 );
%<pc group of size 729 with 6 generators>
%gap> phi := EpimorphismStandardPresentation( Q, 3 : ClassBound := 3 );
%[ f1, f2, f3, f4, f5, f6 ] -> [ f1*f2^2*f3*f4^2*f5^2, f1*f2*f3*f5, f3^2, 
%  f4*f6^2, f5, f6 ]
%gap> Size( Image(phi) );
%729
%\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Primitive Interactive ANUPQ Process Read/Write Functions}

For those familiar with using the `pq' binary as a standalone we  provide
primitive read/write tools to communicate directly  with  an  interactive
{\ANUPQ} process, started via `PqStart'. For the most part, it is  up  to
the user to translate the output strings from `pq'  binary  into  a  form
useful in {\GAP}.

\>PqRead( <i> ) F
\>PqRead() F

read a complete line of  {\ANUPQ}  output,  from  the  <i>th  or  default
interactive {\ANUPQ} process, if there is output to be read  and  returns
`fail' otherwise. When successful, the  line  is  returned  as  a  string
complete with trailing newline, colon, or question-mark character. Please
note that it is possible to be ``too  quick''  (i.e.~the  return  can  be
`fail' purely because the output from {\ANUPQ} is not there yet), but  if
`PqRead' finds any output at all, it waits for a complete line.  `PqRead'
also writes the line read via `Info' at `InfoANUPQ' level 2.  It  doesn't
try to distinguish banner and menu output from other output of  the  `pq'
binary.

\>PqReadAll( <i> ) F
\>PqReadAll() F

read and return as many *complete* lines of  {\ANUPQ}  output,  from  the
<i>th or default interactive {\ANUPQ} process, as there are to  be  read,
*at the time of the call*,  as  a  list  of  strings  with  any  trailing
newlines removed and returns the empty list otherwise.  `PqReadAll'  also
writes each line read via `Info' at `InfoANUPQ' level 2. It  doesn't  try
to distinguish banner and menu output  from  other  output  of  the  `pq'
binary. Whenever `PqReadAll' finds only a partial line, it waits for  the
complete line, thus increasing the probability that it has  captured  all
the output to be had from {\ANUPQ}.

\>PqReadUntil( <i>, <IsMyLine> ) F
\>PqReadUntil( <IsMyLine> ) F
\>PqReadUntil( <i>, <IsMyLine>, <Modify> ) F
\>PqReadUntil( <IsMyLine>, <Modify> ) F

read complete lines  of  {\ANUPQ}  output,  from  the  <i>th  or  default
interactive {\ANUPQ} process, ``chomps'' them (i.e.~removes any  trailing
newline character), emits them to `Info' at `InfoANUPQ' level 2  (without
trying to distinguish banner and menu output from  other  output  of  the
`pq' binary), and applies the function <Modify> (where <Modify>  is  just
the identity map/function for the first two forms)  until  a  ``chomped''
line  <line>  for  which  `<IsMyLine>(  <Modify>(<line>)  )'   is   true.
`PqReadUntil' returns the list of <Modify>-ed ``chomped'' lines read.

*Notes:* 
When provided by the user, <Modify> should be a function that  accepts  a
single string argument.

<IsMyLine> should be a function that is able  to  accept  the  output  of
<Modify> (or take a single string argument when <Modify> is not provided)
and should return a boolean.

If `<IsMyLine>( <Modify>(<line>) )' is  never  true,  `PqReadUntil'  will
wait indefinitely.

\>PqWrite( <i>, <string> ) F
\>PqWrite( <string> ) F

write <string> to the <i>th  or  default  interactive  {\ANUPQ}  process;
<string> must be in exactly the form the {\ANUPQ} standalone expects. The
command is echoed via `Info' at `InfoANUPQ' level 3 (with a  ```ToPQ> '''
prompt); i.e.~do `SetInfoLevel(InfoANUPQ, 3);' to see what is transmitted
to the `pq' binary. `PqWrite' returns `true' if successful in writing  to
the stream of the interactive {\ANUPQ} process, and `fail' otherwise.

*Note:*
If `PqWrite' returns `fail' it means that the {\ANUPQ} process has died.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
