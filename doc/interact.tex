%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  interact.tex    ANUPQ documentation - interactive f'ns      Werner Nickel
%A                                                                Greg Gamble
%%
%A  @(#)$Id$
%%
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Interactive ANUPQ functions}

Here we describe the interactive functions defined by the {\ANUPQ}  share
package, i.e.~the functions  that  manipulate  and  initiate  interactive
{\ANUPQ} processes.

An  interactive  {\ANUPQ}  process  is  initiated  by   `PqStart'   and
terminated  via  `PqQuit';   these   functions   are   described   in
Section~"Starting and Stopping Interactive ANUPQ Processes".

Each interactive {\ANUPQ} function that manipulates  an  already  started
interactive {\ANUPQ} process, has a form where the first argument is  the
integer <i> returned by the initiating `PqStart' command,  and  a  second
form with one argument fewer (where the integer <i> is  discovered  by  a
default mechanism, namely by determining the least integer <i> for  which
there is a currently active interactive {\ANUPQ} process). We  will  thus
commonly say that  ``for  the  <i>th  (or  default)  interactive  {ANUPQ}
process'' a certain function performs a given action. In each case, it is
an error, if <i> is not the index of an active  interactive  process,  or
there are no current active interactive processes.

*Notes*: 
The global method of passing options (via `PushOptions'), should  not  be
used with any of the interactive functions. In fact,  the  `OptionsStack'
should be empty at the time any of the interactive functions is called.

On `quit'ting {\GAP}, `PqQuitAll();' is executed,  which  terminates  all
active interactive  {\ANUPQ}  processes.  If  {\GAP}  is  killed  without
`quit'ting, before all interactive  {\ANUPQ}  processes  are  terminated,
*zombie* processes (still living *child* processes whose  *parents*  have
died), will result. Since zombie processes do consume resources, in  such
an event, the responsible computer user should  seek  out  and  kill  the
still living `pq' children (e.g.~by piping the  output  of  a  `ps'  with
appropriate options, usually `aux' or `ef', to `grep  pq',  to  find  the
process ids, and then using `kill'; try `man ps' and `man kill' if  these
hints are unhelpful).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Starting and Stopping Interactive ANUPQ Processes}

\>PqStart( <G>, <workspace> ) F
\>PqStart( <G> ) F
\>PqStart( <workspace> ) F
\>PqStart() F

activate an iostream for an interactive {\ANUPQ} process (i.e.  `PqStart'
starts up a `pq' binary process and opens a {\GAP} iostream  to  ``talk''
to that process) and returns an integer <i> that can be used to  identify
that process. The argument <G>, if given, should be an *fp group* or  *pc
group* that the user  intends  to  manipute  using  interactive  {\ANUPQ}
functions. If `PqStart' is given an integer argument <workspace> then the
`pq' binary is started up with a workspace (an  integer  array)  of  size
<workspace> (i.e. $4 \times <workspace>$ bytes in a 32-bit  environment);
otherwise, the `pq' binary sets a default workspace of $10000000$.

\>PqQuit( <i> ) F
\>PqQuit() F

closes the stream of the <i>th or default  interactive  {\ANUPQ}  process
and unbinds its `ANUPQData.io' record.

*Note:*
It can happen that the `pq' binary process, and hence the {\GAP} iostream
assigned to communicate with it, can  die,  e.g.~by  the  user  typing  a
`Ctrl-C' while the `pq' binary process is engaged in a long  calculation.
`IsPqProcessAlive' (see~"IsPqProcessAlive")  is  provided  to  check  the
status of the {\GAP} iostream (and hence the status of  the  `pq'  binary
process it was communicating with).

\>PqQuitAll() F

is provided  as  a  convenience,  to  terminate  all  active  interactive
{\ANUPQ} processes with a single command. It is equivalent  to  executing
`PqQuit(<i>)'  for  all  active  interactive   {\ANUPQ}   processes   <i>
(see~"PqQuit").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Interactive ANUPQ Process Utility Functions and Interruption of
an Interactive ANUPQ Process}

\>PqProcessIndex( <i> ) F
\>PqProcessIndex() F

With argument <i>, which must be  a  positive  integer,  `PqProcessIndex'
returns <i> if it corresponds to an active interactive process, or raises
an error. With no arguments it returns  the  default  active  interactive
process or returns `fail' and  emits  a  warning  message  to  `Info'  at
`InfoANUPQ' or `InfoWarning' level 1.

*Note:*
Essentially,  an  interactive  {\ANUPQ}  process  <i>  is  ``active''  if
`ANUPQData.io[<i>]' is bound (i.e.~we still have  some  data  telling  us
about it). Also see~"PqStart".

\>PqProcessIndices() F

returns the list of integer indices of all  active  interactive  {\ANUPQ}
processes (see~"PqProcessIndex" for the meaning of ``active'').

\>IsPqProcessAlive( <i> ) F
\>IsPqProcessAlive() F

return  `true'  if  the  {\GAP}  iostream  of  the  <i>th  (or   default)
interactive {\ANUPQ} process started  by  `PqStart'  is  alive  (i.e.~can
still be written to), or `false', otherwise. (See the notes for~"PqStart"
and~"PqQuit".)

\atindex{interruption}{@interruption of an interactive ANUPQ process}
If the user does not yet have a  `gap>'  prompt  then  usually  the  `pq'
binary is still away doing something and an {\ANUPQ}  interface  function
is still waiting for a reply. Typing a `Ctrl-C'  (i.e.~holding  down  the
`Ctrl' key and typing `c') will stop the waiting and send {\GAP}  into  a
`break'-loop, from which one has no option but to `quit;'. The typing  of
`Ctrl-C', in such a  circumstance,  usually  causes  the  stream  of  the
interactive  {\ANUPQ}  process  to  die;  to  check   this   we   provide
`IsPqProcessAlive' (see~"IsPqProcessAlive").

The {\GAP} iostream of an interactive {\ANUPQ} process will also  die  if
the {\ANUPQ} binary has a segmentation fault. We do hope that this  never
happens to you, but if it does and the failure is reproducible, then it's
a bug and we'd like to know about it. Please read the `README' that comes
with the {\ANUPQ} share package to find out what  to  include  in  a  bug
report and who to email it to.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Interactive Versions of Non-interactive ANUPQ Functions}

\>Pq( <i> : <options> )!{interactive} F
\>Pq( : <options> )!{interactive} F

returns for the finitely presented group <F>, of  the  <i>th  or  default
interactive {\ANUPQ}  process,  the  $p$-quotient  of  <F>  specified  by
<options>, as a pc-group. The group <F>  is  the  group  given  as  first
argument  to  `PqStart'  to  start  the  interactive   {\ANUPQ}   process
(see~"PqStart"). Behind the colon <options> a selection  of  the  options
listed for the non-interactive `Pq' function (see~"Pq") should be  given,
separated by commas like record components (see~"ref:function  call  with
options"), except that  the  options  `SetupFile'  or  `PqWorkspace'  are
ignored by the interactive `Pq'. A pc presentation is  only  computed  if
one has not previously been computed and none of the options given in the
call differ from previous values.

*Note:*
If a pc  presentation  has  previously  been  computed  any  options  not
supplied are assumed to have  the  values  of  the  previous  call  to  a
function that computed a pc presentation, i.e.~it is  ok  to  provide  no
options if a pc presentation has already been computed. Take care though,
if on a previous function call that computed a pc  presentation  you  set
`Metabelian', for example, but on a subsequent  call  to  `Pq'  you  wish
`Metabelian' to be `false', then you must explicitly set  `Metabelian  :=
false' in the `Pq' call (the usual default of `false' is  over-ridden  by
the previous value provided), or alternatively  call  `PqPcPresentation',
which never avoids re-doing the computation, with your intended options.

The following is one of the examples for the non-interactive `Pq'  redone
with the interactive version:

\beginexample
gap> F := FreeGroup("a", "b");; a := F.1;; b := F.2;;
gap> G := F / [a^4, b^4];
<fp group on the generators [ a, b ]>
gap> PqStart(G);
1
gap> SetInfoLevel(InfoANUPQ, 3); # To see behind the scenes
gap> Pq(: Prime := 2, ClassBound := 3 );
#I  ToPQ> 7  #to (Main) p-Quotient Menu
#I  Select option: 
#I  ToPQ> 1  #define group
#I  ToPQ> prime 2
#I  ToPQ> class 3
#I  ToPQ> exponent 0
#I  ToPQ> output 1
#I  ToPQ> generators { a,b }
#I  ToPQ> relations  { a^4,b^4 };
#I  
#I  Lower exponent-2 central series for G
#I  
#I  Group: G to lower exponent-2 central class 1 has order 2^2
#I  
#I  Group: G to lower exponent-2 central class 2 has order 2^5
#I  
#I  Group: G to lower exponent-2 central class 3 has order 2^8
#I  Computation of presentation took 0.00 seconds
#I  
#I  Select option: 
#I  ToPQ> 8  #to Advanced p-Quotient Menu
#I  Select option: 
#I  ToPQ> 25 #set output file
#I  Enter output file name: 
#I  ToPQ> /tmp/filev02Q2b.2/PQ_OUTPUT
#I  Output file in CAYLEY (1) or GAP (2) or Magma (3) format? 
#I  ToPQ> 2  #output in GAP format
#I  Group presentation written in GAP format to file
#I  
#I  Select option: 
<pc group of size 256 with 8 generators>
\endexample

\>PqEpimorphism( <i> : <options> )!{interactive} F
\>PqEpimorphism( : <options> )!{interactive} F

returns for the finitely presented group <F>, of  the  <i>th  or  default
interactive  {\ANUPQ}  process,  an  epimorphism  from   <F>   onto   the
$p$-quotient of <F> specified by <options>. The group <F>  is  the  group
listed as first argument to `PqStart' to start the  interactive  {\ANUPQ}
process (see~"PqStart"). Behind the colon <options> a  selection  of  the
options given for the non-interactive `Pq' function (see~"Pq") should  be
given, separated by commas like record components (see~"ref:function call
with options"), except that the options `SetupFile' or `PqWorkspace'  are
ignored by the interactive `PqEpimorphism' function.

\index{automorphisms!of p groups}
\>PqStandardPresentation( <i>, <p> : <options> )!{interactive} F
\>PqStandardPresentation( <p> : <options> )!{interactive} F
\>PqStandardPresentation( <i>, <G> : <options> )!{interactive} F
\>PqStandardPresentation( <G> : <options> )!{interactive} F
\>StandardPresentation( <i>, <p> : <options> )!{interactive} M
\>StandardPresentation( <p> : <options> )!{interactive} M
\>StandardPresentation( <i>, <G> : <options> )!{interactive} M
\>StandardPresentation( <G> : <options> )!{interactive} M

return, for the finitely presented group <F>  of  the  <i>th  or  default
interactive  {\ANUPQ}  process,  the  standard   presentation   for   the
$p$-quotient of <F> specified by the <p> or <G> argument  and  <options>,
as a pc group. The group <F> is the group  given  as  first  argument  to
`PqStart' to start  the  interactive  {\ANUPQ}  process  (see~"PqStart").
Behind the colon <options> a selection  of  the  options  given  for  the
non-interactive             `PqStandardPresentation'             function
(see~"PqStandardPresentation") should be given, separated by commas  like
record components (see~"ref:function call with options"), except that the
options `SetupFile' or  `PqWorkspace'  are  ignored  by  the  interactive
`PqStandardPresentation' and `StandardPresentation' functions.

If the  user  supplies  a  prime  <p>  then  `PqStandardPresentation'  or
`StandardPresentation' computes a $p$-quotient of <F> for the prime <p>.

Alternatively, a user may supply a pc group <G> which is  a  $p$-quotient
of <F>, and if she does so, the automorphism group of <G> must be  known.
The presentation for <G> can be constructed by an initial  call  to  `Pq'
(see "Pq"). For <G> one usually chooses a class 1  $p$-quotient  of  <F>,
since the automorphism group of <G>  must  be  known  and  this  is  most
readily available when <G> is an  elementary  abelian  group.  Where  the
necessary information is available for a $p$-quotient  of  higher  class,
one can  apply  the  standard  presentation  algorithm  from  that  class
onwards.

Taking  one  of  the  examples  for  the   non-interactive   version   of
`StandardPresentation'  (see~"StandardPresentation")  that  required  two
separate calls to the `pq' binary, we now show that with the  interactive
version of `StandardPresentation' how it can be  done  by  setting  up  a
dialogue with just the one `pq' process:

\beginexample
gap> F4 := FreeGroup( "a", "b", "c", "d" );;
gap> a := F4.1;; b := F4.2;; c := F4.3;; d := F4.4;;
gap> G4 := F4 / [ b^4, b^2 / Comm(Comm (b, a), a), d^16,
>                 a^16 / (c * d), b^8 / (d * c^4) ];
<fp group on the generators [ a, b, c, d ]>
gap> SetInfoLevel(InfoANUPQ, 1); #Only essential Info please
gap> PqStart(G4); #Start a new interactive process for a new group
2
gap> K := Pq( 2 : Prime := 2, ClassBound := 1 ); #`pq' process no. is 2
<pc group of size 4 with 2 generators>
gap> AutomorphismGroup( K );     #Make sure Aut. group is known
<group with 4 generators>
gap> StandardPresentation( 2, K : ClassBound := 14, PcgsAutomorphisms );
<fp group with 53 generators>
\endexample

\>EpimorphismPqStandardPresentation( <i>, <p> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <p> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <i>, <G> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <G> : <options> )!{interactive} F
\>EpimorphismStandardPresentation( <i>, <p> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <p> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <i>, <G> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <G> : <options> )!{interactive} M

Each of the above functions accepts the same arguments and options as the
function `StandardPresentation' (see~"StandardPresentation") and  returns
an epimorphism from the finitely presented group  <F>  of  the  <i>th  or
default interactive {\ANUPQ} process onto the  finitely  presented  group
given  by  a  standard  presentation,  i.e.~if  <S>   is   the   standard
presentation   computed   for   <F>   by   `StandardPresentation'    then
`EpimorphismStandardPresentation' returns the epimorphism from <F> to the
group with presentation <S>. The group <F> is the group  given  as  first
argument  to  `PqStart'  to  start  the  interactive   {\ANUPQ}   process
(see~"PqStart").

Taking        our         earlier         non-interactive         example
(see~"EpimorphismPqStandardPresentation")   we   again   illustrate   how
something thta required two separate calls to the `pq' binary can now  be
achieved with a dialogue with just one `pq' process.

\beginexample
gap> F := FreeGroup (6);;
gap> x := F.1;; y := F.2;; z := F.3;; w := F.4;; a := F.5;; b := F.6;;
gap> R := [x^3 / w, y^3 / w * a^2 * b^2, w^3 / b,
>          Comm (y, x) / z, Comm (z, x), Comm (z, y) / a, z^3 ];;
gap> Q := F / R;;
gap> PqStart(Q); #Start a new interactive process for a new group       
3
gap> G := Pq( 3 : Prime := 3, ClassBound := 3 );
<pc group of size 729 with 6 generators>
gap> phi := EpimorphismStandardPresentation( 3, 3 : ClassBound := 3 );
[ f1, f2, f3, f4, f5, f6 ] -> [ f1*f2^2*f3*f4^2*f5^2, f1*f2*f3*f5, f3^2, 
  f4*f6^2, f5, f6 ]
gap> Size( Image(phi) );
729
\endexample

\>PqDescendants( <i> : <options> )!{interactive} F
\>PqDescendants( : <options> )!{interactive} F

returns for the the pc-group <G>, of the  <i>th  or  default  interactive
{\ANUPQ} process, which must be of prime power  order  with  a  confluent
power-commutator presentation (see~"ref:IsConfluent!for  pc  groups"),  a
list of descendants (pc groups) of <G>. The group <G> is the group  given
as first argument to `PqStart' to start the interactive {\ANUPQ}  process
(see~"PqStart"). Behind the colon <options> a selection  of  the  options
listed    for    the     non-interactive     `PqDescendants'     function
(see~"PqDescendants") should be given, separated by  commas  like  record
components  (see~"ref:function  call  with  options"),  except  that  the
options `SetupFile' or  `PqWorkspace'  are  ignored  by  the  interactive
`PqDescendants'.

If <G> does *not* have $p$-class 1, then the automorphism  group  of  <G>
must be known. In practice, the automorphism group  of  <G>  is  computed
using the {\GAP} command `AutomorphismGroup'. Note that the {\GAP}  share
package {\AutPGrp} provides an algorithm for computing  the  automorphism
group of a $p$-group which performs better than the  standard  method  in
{\GAP}.

If the automorphism group  of  <G>  is  not  soluble  or  if  the  option
`PcgsAutomorphisms' (see below) is not used, then the  `pq'  binary  will
call {\GAP} together with the {\AutPGrp}  package  as  a  subprocess  for
certain orbit-stabilizer calculations.

Let us now repeat the examples previously given for  the  non-interactive
`PqDescendants',  but  this  time  with  the   interactive   version   of
`PqDescendants':

\beginexample
gap> F := FreeGroup( "a", "b" );; a := F.1;; b := F.2;;
gap> G := PcGroupFpGroup( F / [ a^2, b^2, Comm(b, a) ] );
<pc group of size 4 with 2 generators>
gap> PqStart(G);
4
gap> #This is now the 4th interactive process running
gap> des := PqDescendants( 4 : OrderBound := 6, ClassBound := 5,
>                              AllDescendants );;
gap> Length(des);
83
gap> List(des, Size);
[ 8, 8, 8, 16, 16, 16, 32, 16, 16, 16, 16, 16, 32, 32, 64, 64, 32, 32, 32, 
  32, 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 32, 32, 32, 32, 
  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 32, 32, 32, 32, 32, 64, 64, 64, 
  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 
  64, 64, 64, 64, 64, 64, 64 ]
gap> List(des, d -> Length( PCentralSeries( d, 2 ) ) - 1 );
[ 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
  4, 4, 4, 5, 5, 5, 5, 5 ]
\endexample

In the second example we compute all  capable descendants of order  27 of
the  elementary abelian group of order 9.  

\beginexample
gap> F := FreeGroup( 2, "g" );;                                 
gap> G := PcGroupFpGroup( F / [ F.1^3, F.2^3, Comm(F.1, F.2) ] );
<pc group of size 9 with 2 generators>
gap> A := AutomorphismGroup( G );
<group with 4 generators>
gap> IsSolvable(A);
true
gap> Pcgs(A);
Pcgs([ [ g1, g2 ] -> [ g1, g2^2 ], [ g1, g2 ] -> [ g1, g1*g2 ], 
  [ g1, g2 ] -> [ g1^2*g2, g1*g2 ], [ g1, g2 ] -> [ g2^2, g1 ], 
  [ g1, g2 ] -> [ g1^2, g2^2 ] ])
gap> PqStart(G); #This will now be the 5th interactive process running
5
gap> des := PqDescendants( 5 : OrderBound := 3, ClassBound := 2,
>                              PcgsAutomorphisms );
[ <pc group of size 27 with 3 generators>, 
  <pc group of size 27 with 3 generators> ]
gap> List(des, d -> Length( PCentralSeries( d, 3 ) ) - 1 );
[ 2, 2 ]
\endexample

In  the  third  example,  we  compute  all  capable  descendants  of  the
elementary abelian group of order  $5^2$ which have exponent-$5$ class at
most $3$, exponent $5$, and are metabelian.

\beginexample
gap> F := FreeGroup( 2, "g" );;
gap> G := PcGroupFpGroup( F / [ F.1^5, F.2^5, Comm(F.2, F.1) ] );
<pc group of size 25 with 2 generators>
gap> PqStart(G); #This will now be the 6th interactive process running
6
gap> des := PqDescendants( 6 : Metabelian, ClassBound := 3,
>                              Exponent := 5 );
[ <pc group of size 125 with 3 generators>, 
  <pc group of size 625 with 4 generators>, 
  <pc group of size 3125 with 5 generators> ]
gap> List(des, d -> Length( PCentralSeries( d, 5 ) ) - 1 );
[ 2, 3, 3 ]
gap> List(des, d -> Length( DerivedSeries( d ) ) );
[ 3, 3, 3 ]
gap> List(des, d -> Maximum( List( Elements(d), Order ) ) );
[ 5, 5, 5 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Low-level Interactive ANUPQ Functions based on menu items of the
pq binary}

*WARNING!! MOST OF THE FOLLOWING FUNCTIONS HAVE FEW SAFEGUARDS ... WE'RE
 WORKING ON IT, BUT IT'S USE AT YOUR OWN RISK AT THE MOMENT ... IF YOU
 DON'T DEFINE A PC PRESENTATION BEFORE DOING CERTAIN COMMANDS, THE pq
 BINARY WILL PROBABLY DIE ON YOU*

The `pq' binary has 5 menus, the details of which  the  reader  will  not
normally need to know, but if she wishes to know the details they may  be
found in the standalone manual: `guide.dvi'.  Both  `guide.dvi'  and  the
`pq' binary refer to the items of these 5 menus as ``options'', which  do
*not* correspond in any way to the options used  by  any  of  the  {\GAP}
functions that interface with the `pq' binary.

*Main $p$-Quotient menu commands*

\>PqPcPresentation( <i> : <options> ) F
\>PqPcPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> for the group of  that  process  so  that  the  `pq'  binary
computes a pc presentation, where the group of a process is the one given
as first argument when `PqStart' was called to initiate that process (for
process <i> the group is stored as `ANUPQData.io[<i>].group').

*Note:* For those  familiar  with  the  `pq'  binary,  `PqPcPresentation'
performs option 1 of the main $p$-Quotient menu.

\>PqSavePcPresentation( <i>, <filename> ) F
\>PqSavePcPresentation( <filename> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to save the pc presentation previously computed for the  group  of
that process, where the group of a process is  the  one  given  as  first
argument when `PqStart' was called to initiate that process.

*Note:* For those familiar with the `pq'  binary,  `PqSavePcPresentation'
performs option 2 of the main $p$-Quotient menu.

\>PqRestorePcPresentation( <i>, <filename> ) F
\>PqRestorePcPresentation( <filename> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to restore the pc presentation previously saved to <filename>  for
the group of that process, where the group of a process is the one  given
as first argument when `PqStart' was called to initiate that process.

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqRestorePcPresentation'
performs option 3 of the main $p$-Quotient menu.

\>PqDisplayPcPresentation( <i> ) F
\>PqDisplayPcPresentation() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary  to  display  the  pc   presentation   previously   computed   (by
`PqPcPresentation'; see~"PqPcPresentation") or  restored  from  file  (by
`PqRestorePcPresentation'; see~"PqRestorePcPresentation") for  the  group
of that process, where the group of a process is the one given  as  first
argument when `PqStart' was called to initiate that process. To  set  the
amount of  information  this  command  displays  you  may  wish  to  call
`PqSetPrintLevel' first (see~"PqSetPrintLevel").

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqDisplayPcPresentation'
performs option 4 of the main $p$-Quotient menu.

\>PqSetPrintLevel( <i>, <lev> ) F
\>PqSetPrintLevel( <lev> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to set the print level to <lev>, in the main $p$-Quotient menu.

*Note:* For  those  familiar  with  the  `pq'  binary,  `PqSetPrintLevel'
performs option 5 of the main $p$-Quotient menu.

\>PqNextClass( <i> ) F
\>PqNextClass() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
to calculate the next class of `<datarec>.group'. 

*Note:* For those familiar with the `pq' binary,  `PqNextClass'  performs
option 6 of the main $p$-Quotient menu.

\>PqPCover( <i> ) F
\>PqPCover() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
to compute the $p$-covering group of `<datarec>.group'.

*Note:* For those familiar with  the  `pq'  binary,  `PqPCover'  performs
option 7 of the main $p$-Quotient menu.

*Advanced $p$-Quotient menu commands*

\>PqCollect( <i>, <word> ) F
\>PqCollect( <word> ) F

for the <i>th or default interactive {\ANUPQ} process, instructs the `pq'
binary to do a collection on <word> a string representing the product  of
three generators, e.g. `"x3*x2*x1"'.

*Note:* For those familiar with the  `pq'  binary,  `PqCollect'  performs
option 1 of the Advanced $p$-Quotient menu.

\>PqAPQSetPrintLevel( <i>, <lev> ) F
\>PqAPQSetPrintLevel( <lev> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to set the print level to  <lev>,  in  the  Advanced  $p$-Quotient
menu.

*Note:* For those familiar with  the  `pq'  binary,  `PqAPQSetPrintLevel'
performs option 5 of the Advanced $p$-Quotient menu.

\>PqWritePcPresentation( <i>, <outfile> ) F
\>PqWritePcPresentation( <outfile> ) F

for the <i>th or default interactive {\ANUPQ}  process,  tells  the  `pq'
binary to write a pc presentation to <outfile>  for  the  group  of  that
process for which a pc presentation has been previously  computed,  where
the group of a process is the one given as first argument when  `PqStart'
was called to initiate that process (for process <i> the group is  stored
as  `ANUPQData.io[<i>].group').  If  a  pc  presentation  has  not   been
previously computed by the `pq' binary, then `pq' is called to compute it
first, effectively invoking `PqPcPresentation' (see~"PqPcPresentation").

*Note:* For those familiar with the `pq' binary,  `PqPcWritePresentation'
performs option 25 of the advanced $p$-Quotient menu.

*Standard Presentation menu commands*

\>PqSPPcPresentation( <i> : <options> ) F
\>PqSPPcPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> for the group of  that  process  so  that  the  `pq'  binary
computes a pc presentation, where the group of a process is the one given
as first argument when `PqStart' was called to initiate that process (for
process <i> the group is stored as `ANUPQData.io[<i>].group').

*Note:* For those familiar with  the  `pq'  binary,  `PqSPPcPresentation'
performs option 1 of the Standard Presentation menu.

\>PqSPStandardPresentation( <i> : <options> ) F
\>PqSPStandardPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> to compute a standard presentation for  the  group  of  that
process and a previously computed $p$-quotient of the  group,  where  the
group of a process is the one given as first argument when `PqStart'  was
called to initiate that process (for process <i> the group is  stored  as
`ANUPQData.io[<i>].group'   and   the   $p$-quotient   is    stored    as
`ANUPQData.io[<i>].pQuotient'). If a $p$-quotient of the  group  has  not
been previously computed a class 1 $p$-quotient is computed.

*Note:* For those familiar with  the  `pq'  binary,  `PqSPPcPresentation'
performs option 2 of the Standard Presentation menu.

\>PqSPSetPrintLevel( <i>, <lev> ) F
\>PqSPSetPrintLevel( <lev> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to set the print level to  <lev>,  in  the  Standard  Presentation
menu.

*Note:* For those familiar  with  the  `pq'  binary,  `PqSPSetPrintLevel'
performs option 5 of the Standard Presentation menu.

\>PqSPIsomorphism( <i> ) F
\>PqSPIsomorphism() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute the isomorphism from the generators of the automorphism
group of `ANUPQData.io[<i>].pQuotient' to the generators for the standard
presentation.

*Note:* For  those  familiar  with  the  `pq'  binary,  `PqSPIsomorphism'
performs option 8 of the Standard Presentation menu.

*Main $p$-Group Generation menu commands*

\>PqPGSupplyAutomorphisms( <i> ) F
\>PqPGSupplyAutomorphisms() F

for the <i>th or default interactive {\ANUPQ} process, supplies the  `pq'
binary with the automorphism group data needed for `<datarec>.group'.

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqPGSupplyAutomorphisms'
performs option 1 of the main $p$-Group Generation menu.

\>PqPGConstructDescendants( <i> : <options> ) F
\>PqPGConstructDescendants( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> to the `pq' binary to  construct  descendants.  The  options
possible are all those given  for  `PqDescendants'  (see~"PqDescendants")
except for `SubList' and `SetupFile'.

*Note:* 
For those  familiar  with  the  `pq'  binary,  `PqPGConstructDescendants'
performs option 5 of the main $p$-Group Generation menu.

%*Advanced $p$-Group Generation menu commands*
%none done yet

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Primitive Interactive ANUPQ Process Read/Write Functions}

For those familiar with using the `pq' binary as a standalone we  provide
primitive read/write tools to communicate directly  with  an  interactive
{\ANUPQ} process, started via `PqStart'. For the most part, it is  up  to
the user to translate the output strings from `pq'  binary  into  a  form
useful in {\GAP}.

\>PqRead( <i> ) F
\>PqRead() F

read a complete line of  {\ANUPQ}  output,  from  the  <i>th  or  default
interactive {\ANUPQ} process, if there is output to be read  and  returns
`fail' otherwise. When successful, the  line  is  returned  as  a  string
complete with trailing newline, colon, or question-mark character. Please
note that it is possible to be ``too  quick''  (i.e.~the  return  can  be
`fail' purely because the output from {\ANUPQ} is not there yet), but  if
`PqRead' finds any output at all, it waits for a complete line.  `PqRead'
also writes the line read via `Info' at `InfoANUPQ' level 2.  It  doesn't
try to distinguish banner and menu output from other output of  the  `pq'
binary.

\>PqReadAll( <i> ) F
\>PqReadAll() F

read and return as many *complete* lines of  {\ANUPQ}  output,  from  the
<i>th or default interactive {\ANUPQ} process, as there are to  be  read,
*at the time of the call*,  as  a  list  of  strings  with  any  trailing
newlines removed and returns the empty list otherwise.  `PqReadAll'  also
writes each line read via `Info' at `InfoANUPQ' level 2. It  doesn't  try
to distinguish banner and menu output  from  other  output  of  the  `pq'
binary. Whenever `PqReadAll' finds only a partial line, it waits for  the
complete line, thus increasing the probability that it has  captured  all
the output to be had from {\ANUPQ}.

\>PqReadUntil( <i>, <IsMyLine> ) F
\>PqReadUntil( <IsMyLine> ) F
\>PqReadUntil( <i>, <IsMyLine>, <Modify> ) F
\>PqReadUntil( <IsMyLine>, <Modify> ) F

read complete lines  of  {\ANUPQ}  output,  from  the  <i>th  or  default
interactive {\ANUPQ} process, ``chomps'' them (i.e.~removes any  trailing
newline character), emits them to `Info' at `InfoANUPQ' level 2  (without
trying to distinguish banner and menu output from  other  output  of  the
`pq' binary), and applies the function <Modify> (where <Modify>  is  just
the identity map/function for the first two forms)  until  a  ``chomped''
line  <line>  for  which  `<IsMyLine>(  <Modify>(<line>)  )'   is   true.
`PqReadUntil' returns the list of <Modify>-ed ``chomped'' lines read.

*Notes:* 
When provided by the user, <Modify> should be a function that  accepts  a
single string argument.

<IsMyLine> should be a function that is able  to  accept  the  output  of
<Modify> (or take a single string argument when <Modify> is not provided)
and should return a boolean.

If `<IsMyLine>( <Modify>(<line>) )' is  never  true,  `PqReadUntil'  will
wait indefinitely.

\>PqWrite( <i>, <string> ) F
\>PqWrite( <string> ) F

write <string> to the <i>th  or  default  interactive  {\ANUPQ}  process;
<string> must be in exactly the form the {\ANUPQ} standalone expects. The
command is echoed via `Info' at `InfoANUPQ' level 3 (with a  ```ToPQ> '''
prompt); i.e.~do `SetInfoLevel(InfoANUPQ, 3);' to see what is transmitted
to the `pq' binary. `PqWrite' returns `true' if successful in writing  to
the stream of the interactive {\ANUPQ} process, and `fail' otherwise.

*Note:*
If `PqWrite' returns `fail' it means that the {\ANUPQ} process has died.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
