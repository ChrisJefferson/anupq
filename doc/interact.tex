%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%A  interact.tex    ANUPQ documentation - interactive f'ns      Werner Nickel
%A                                                                Greg Gamble
%%
%A  @(#)$Id$
%%
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Interactive ANUPQ functions}

Here we describe the interactive functions defined by the {\ANUPQ}  share
package, i.e.~the functions  that  manipulate  and  initiate  interactive
{\ANUPQ} processes. These are functions that extract  information  via  a
dialogue with a running `pq' process (process used in  the  UNIX  sense).
Occasionally, a user needs the ``next step''; the functions  provided  in
this chapter make use of data from previous steps retained  by  the  `pq'
binary, thus allowing the user to interact with the `pq' binary like  one
can when one uses the `pq' binary as a  stand-alone  (see~`guide.dvi'  in
the `standalone-doc' directory).

An  interactive  {\ANUPQ}  process  is  initiated  by   `PqStart'   and
terminated  via  `PqQuit';   these   functions   are   described   in
Section~"Starting and Stopping Interactive ANUPQ Processes".

Each interactive {\ANUPQ} function that manipulates  an  already  started
interactive {\ANUPQ} process, has a form where the first argument is  the
integer <i> returned by the initiating `PqStart' command,  and  a  second
form with one argument fewer (where the integer <i> is  discovered  by  a
default mechanism, namely by determining the least integer <i> for  which
there is a currently active interactive {\ANUPQ} process). We  will  thus
commonly say that ``for  the  <i>th  (or  default)  interactive  {\ANUPQ}
process'' a certain function performs a given action. In each case, it is
an error, if <i> is not the index of an active  interactive  process,  or
there are no current active interactive processes.

*Notes*: 
The global method of passing options (via `PushOptions'), should  not  be
used with any of the interactive functions. In fact,  the  `OptionsStack'
should be empty at the time any of the interactive functions is called.

On `quit'ting {\GAP}, `PqQuitAll();' is executed,  which  terminates  all
active interactive  {\ANUPQ}  processes.  If  {\GAP}  is  killed  without
`quit'ting, before all interactive  {\ANUPQ}  processes  are  terminated,
*zombie* processes (still living *child* processes whose  *parents*  have
died), will result. Since zombie processes do consume resources, in  such
an event, the responsible computer user should  seek  out  and  kill  the
still living `pq' children (e.g.~by piping the  output  of  a  `ps'  with
appropriate options, usually `aux' or `ef', to `grep  pq',  to  find  the
process ids, and then using `kill'; try `man ps' and `man kill' if  these
hints are unhelpful).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Starting and Stopping Interactive ANUPQ Processes}

\>PqStart( <G>, <workspace> : <options> ) F
\>PqStart( <G> : <options> ) F
\>PqStart( <workspace> : <options> ) F
\>PqStart(: <options> ) F

activate an iostream for an interactive {\ANUPQ} process (i.e.  `PqStart'
starts up a `pq' binary process and opens a {\GAP} iostream  to  ``talk''
to that process) and returns an integer <i> that can be used to  identify
that process. The argument <G>, if given, should be an *fp group* or  *pc
group* that the user  intends  to  manipute  using  interactive  {\ANUPQ}
functions. If `PqStart' is given an integer argument <workspace> then the
`pq' binary is started up with a workspace (an  integer  array)  of  size
<workspace> (i.e. $4 \times <workspace>$ bytes in a 32-bit  environment);
otherwise, the `pq' binary sets a default workspace of $10000000$.

The  only  <options>  currently  recognised  by  `PqStart'  are  `Prime',
`Exponent' and  `Relators'  (see  Chapter~"ANUPQ  options"  for  detailed
descriptions of these options)  and  if  provided  they  are  essentially
global for the interactive {\ANUPQ} process, except that any  interactive
function interacting with the process and passing new  values  for  these
options will over-ride the global values.

\>PqQuit( <i> ) F
\>PqQuit() F

closes the stream of the <i>th or default  interactive  {\ANUPQ}  process
and unbinds its `ANUPQData.io' record.

*Note:*
It can happen that the `pq' binary process, and hence the {\GAP} iostream
assigned to communicate with it, can  die,  e.g.~by  the  user  typing  a
`Ctrl-C' while the `pq' binary process is engaged in a long  calculation.
`IsPqProcessAlive' (see~"IsPqProcessAlive")  is  provided  to  check  the
status of the {\GAP} iostream (and hence the status of  the  `pq'  binary
process it was communicating with).

\>PqQuitAll() F

is provided  as  a  convenience,  to  terminate  all  active  interactive
{\ANUPQ} processes with a single command. It is equivalent  to  executing
`PqQuit(<i>)'  for  all  active  interactive   {\ANUPQ}   processes   <i>
(see~"PqQuit").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Interactive ANUPQ Process Utility Functions}

\>PqProcessIndex( <i> ) F
\>PqProcessIndex() F

With argument <i>, which must be  a  positive  integer,  `PqProcessIndex'
returns <i> if it corresponds to an active interactive process, or raises
an error. With no arguments it returns  the  default  active  interactive
process or returns `fail' and  emits  a  warning  message  to  `Info'  at
`InfoANUPQ' or `InfoWarning' level 1.

*Note:*
Essentially,  an  interactive  {\ANUPQ}  process  <i>  is  ``active''  if
`ANUPQData.io[<i>]' is bound (i.e.~we still have  some  data  telling  us
about it). Also see~"PqStart".

\>PqProcessIndices() F

returns the list of integer indices of all  active  interactive  {\ANUPQ}
processes (see~"PqProcessIndex" for the meaning of ``active'').

\>IsPqProcessAlive( <i> ) F
\>IsPqProcessAlive() F

return  `true'  if  the  {\GAP}  iostream  of  the  <i>th  (or   default)
interactive {\ANUPQ} process started  by  `PqStart'  is  alive  (i.e.~can
still be written to), or `false', otherwise. (See the notes for~"PqStart"
and~"PqQuit".)

\atindex{interruption}{@interruption of an interactive ANUPQ process}
If the user does not yet have a  `gap>'  prompt  then  usually  the  `pq'
binary is still away doing something and an {\ANUPQ}  interface  function
is still waiting for a reply. Typing a `Ctrl-C'  (i.e.~holding  down  the
`Ctrl' key and typing `c') will stop the waiting and send {\GAP}  into  a
`break'-loop, from which one has no option but to `quit;'. The typing  of
`Ctrl-C', in such a  circumstance,  usually  causes  the  stream  of  the
interactive  {\ANUPQ}  process  to  die;  to  check   this   we   provide
`IsPqProcessAlive' (see~"IsPqProcessAlive").

The {\GAP} iostream of an interactive {\ANUPQ} process will also  die  if
the {\ANUPQ} binary has a segmentation fault. We do hope that this  never
happens to you, but if it does and the failure is reproducible, then it's
a bug and we'd like to know about it. Please read the `README' that comes
with the {\ANUPQ} share package to find out what  to  include  in  a  bug
report and who to email it to.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Interactive Versions of Non-interactive ANUPQ Functions}

\>Pq( <i> : <options> )!{interactive} F
\>Pq( : <options> )!{interactive} F

returns for the finitely presented group <F>, of  the  <i>th  or  default
interactive {\ANUPQ}  process,  the  $p$-quotient  of  <F>  specified  by
<options>, as a pc-group. The group <F>  is  the  group  given  as  first
argument  to  `PqStart'  to  start  the  interactive   {\ANUPQ}   process
(see~"PqStart"). Following the colon <options> a selection of the options
listed for the non-interactive `Pq' function (see~"Pq") should be  given,
separated by commas like record components (see~"ref:function  call  with
options"), except that  the  options  `SetupFile'  or  `PqWorkspace'  are
ignored by the interactive `Pq' i.e.~the following options are recognised
by the interactive `Pq' function:

\beginlist

\atindex{option Prime}{@option \noexpand`Prime'}
\item{}`Prime := <p>'

\atindex{option ClassBound}{@option \noexpand`ClassBound'}
\item{}`ClassBound := <n>'

\atindex{option Exponent}{@option \noexpand`Exponent'}
\item{}`Exponent := <n>'

\atindex{option Relators}{@option \noexpand`Relators'}
\item{}`Relators := <rels>'

\atindex{option Metabelian}{@option \noexpand`Metabelian'}
\item{}`Metabelian'

\atindex{option GroupName}{@option \noexpand`GroupName'}
\item{}`GroupName := <name>'

\atindex{option OutputLevel}{@option \noexpand`OutputLevel'}
\item{}`OutputLevel := <n>'

\endlist

Detailed descriptions of the above options may be found in Chapter~"ANUPQ
options".

As  a  minimum  the  user  *must*  supply  values  for  the  `Prime'  and
`ClassBound' options, though `Prime' need not be passed to  `Pq'  in  the
case it has previously been provided to  `PqStart'  (see~"PqStart")  when
starting the interactive process. A pc presentation is only  computed  if
one has not previously been computed and none of the options given in the
call differ from previous values.

*Note:*
If a pc  presentation  has  previously  been  computed  any  options  not
supplied are assumed to have  the  values  of  the  previous  call  to  a
function that computed a pc presentation, i.e.~it is  ok  to  provide  no
options if a pc presentation has already been computed. Take care though,
if on a previous function call that computed a pc  presentation  you  set
`Metabelian', for example, but on a subsequent  call  to  `Pq'  you  wish
`Metabelian' to be `false', then you must explicitly set  `Metabelian  :=
false' in the `Pq' call (the usual default of `false' is  over-ridden  by
the previous value provided), or alternatively  call  `PqPcPresentation',
which never avoids re-doing the computation, with your intended options.

The following is one of the examples for the non-interactive `Pq'  redone
with the interactive version:

\beginexample
gap> F := FreeGroup("a", "b");; a := F.1;; b := F.2;;
gap> G := F / [a^4, b^4];
<fp group on the generators [ a, b ]>
gap> PqStart(G);
1
gap> SetInfoLevel(InfoANUPQ, 3); #To see what the `pq' binary is doing
gap> Pq(: Prime := 2, ClassBound := 3 );
#I  Computation of presentation took 0.00 seconds
#I  Group: <grp> to lower exponent-2 central class 3 has order 2^8
#I  Group: <grp> to lower exponent-2 central class 3 has order 2^8
#I  Group defining relations:
#I  4 1
#I  0
#I  4 2
#I  0
#I  Relationship between group defining generators and consistent
#I  power-commutator presentation generators:
#I  1    = .1
#I  1^-1 = .1 .4
#I  2    = .2
#I  2^-1 = .2 .5
#I  Values of power-commutator presentation generators
#I  Class 1
#I  1 is defined on image of defining generator 1
#I  2 is defined on image of defining generator 2
#I  Class 2
#I  3 is defined on [2, 1] = 2 1 
#I  4 is defined on 1^2 = 1 1 
#I  5 is defined on 2^2 = 2 2 
#I  Class 3
#I  6 is defined on [3, 1] = 2 1 1 
#I  7 is defined on [3, 2] = 2 1 2 
#I  8 is defined on [4, 2] = 1 1 2 
#I  Non-trivial powers:
#I   .1^2 = .4
#I   .2^2 = .5
#I   .3^2 = .6 .8
#I  Non-trivial commutators:
#I  [ .2, .1 ] = .3
#I  [ .3, .1 ] = .6
#I  [ .3, .2 ] = .7
#I  [ .4, .2 ] = .8
#I  [ .5, .1 ] = .6 .7 .8
<pc group of size 256 with 8 generators>
\endexample

\>PqEpimorphism( <i> : <options> )!{interactive} F
\>PqEpimorphism( : <options> )!{interactive} F

returns for the finitely presented group <F>, of  the  <i>th  or  default
interactive  {\ANUPQ}  process,  an  epimorphism  from   <F>   onto   the
$p$-quotient of <F> specified by <options>. The group <F>  is  the  group
listed as first argument to `PqStart' to start the  interactive  {\ANUPQ}
process (see~"PqStart"). Following the colon <options> a selection of the
options given for the non-interactive `Pq' function (see~"Pq") should  be
given, separated by commas like record components (see~"ref:function call
with options"), except that the options `SetupFile' or `PqWorkspace'  are
ignored by the interactive `PqEpimorphism' function.  As  a  minimum  the
user must supply values for the `Prime' and `ClassBound' options.

\index{automorphisms!of $p$-groups}
\>PqStandardPresentation( <i>, <p> : <options> )!{interactive} F
\>PqStandardPresentation( <p> : <options> )!{interactive} F
\>PqStandardPresentation( <i>, <G> : <options> )!{interactive} F
\>PqStandardPresentation( <G> : <options> )!{interactive} F
\>StandardPresentation( <i>, <p> : <options> )!{interactive} M
\>StandardPresentation( <p> : <options> )!{interactive} M
\>StandardPresentation( <i>, <G> : <options> )!{interactive} M
\>StandardPresentation( <G> : <options> )!{interactive} M

return, for the finitely presented group <F>  of  the  <i>th  or  default
interactive  {\ANUPQ}  process,  the  standard   presentation   for   the
$p$-quotient of <F> specified by the <p> or <G> argument  and  <options>,
as a pc group. The group <F> is the group  given  as  first  argument  to
`PqStart' to start  the  interactive  {\ANUPQ}  process  (see~"PqStart").
Following the colon <options> a selection of the options  given  for  the
non-interactive             `PqStandardPresentation'             function
(see~"PqStandardPresentation") should be given, separated by commas  like
record components (see~"ref:function call with options"), except that the
options `SetupFile' or  `PqWorkspace'  are  ignored  by  the  interactive
`PqStandardPresentation' and `StandardPresentation'  functions,  i.e.~the
following options are recognised:

\beginlist

\atindex{option ClassBound}{@option \noexpand`ClassBound'}
\item{}`ClassBound := <n>'

\atindex{option Exponent}{@option \noexpand`Exponent'}
\item{}`Exponent := <n>'

\atindex{option Metabelian}{@option \noexpand`Metabelian'}
\item{}`Metabelian'

\atindex{option GroupName}{@option \noexpand`GroupName'}
\item{}`GroupName := <name>'

\atindex{option PcgsAutomorphisms}{@option \noexpand`PcgsAutomorphisms'}
\item{}`PcgsAutomorphisms'

\atindex{option OutputLevel}{@option \noexpand`OutputLevel'}
\item{}`OutputLevel := <n>'

\atindex{option StandardPresentationFile}%
{@option \noexpand`StandardPresentationFile'}
\item{}`StandardPresentationFile := <filename>'

\endlist

Detailed descriptions of the above options may be found in Chapter~"ANUPQ
options".

If the  user  supplies  a  prime  <p>  then  `PqStandardPresentation'  or
`StandardPresentation' computes a $p$-quotient of <F> for the prime <p>.

Alternatively, a user may supply a pc group <G> which is  a  $p$-quotient
of <F>, and if she does so, the automorphism group of <G> must be  known.
The presentation for <G> can be constructed by an initial  call  to  `Pq'
(see "Pq"). For <G> one usually chooses a class 1  $p$-quotient  of  <F>,
since the automorphism group of <G>  must  be  known  and  this  is  most
readily available when <G> is an  elementary  abelian  group.  Where  the
necessary information is available for a $p$-quotient  of  higher  class,
one can  apply  the  standard  presentation  algorithm  from  that  class
onwards.

Taking  one  of  the  examples  for  the   non-interactive   version   of
`StandardPresentation'  (see~"StandardPresentation")  that  required  two
separate calls to the `pq' binary, we now show that with the  interactive
version of `StandardPresentation' how it can be  done  by  setting  up  a
dialogue with just the one `pq' process:

\beginexample
gap> F4 := FreeGroup( "a", "b", "c", "d" );;
gap> a := F4.1;; b := F4.2;; c := F4.3;; d := F4.4;;
gap> G4 := F4 / [ b^4, b^2 / Comm(Comm (b, a), a), d^16,
>                 a^16 / (c * d), b^8 / (d * c^4) ];
<fp group on the generators [ a, b, c, d ]>
gap> SetInfoLevel(InfoANUPQ, 1); #Only essential Info please
gap> PqStart(G4); #Start a new interactive process for a new group
2
gap> K := Pq( 2 : Prime := 2, ClassBound := 1 ); #`pq' process no. is 2
<pc group of size 4 with 2 generators>
gap> AutomorphismGroup( K );     #Make sure Aut. group is known
<group with 4 generators>
gap> StandardPresentation( 2, K : ClassBound := 14, PcgsAutomorphisms );
<fp group with 53 generators>
\endexample

\>EpimorphismPqStandardPresentation( <i>, <p> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <p> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <i>, <G> : <options> )!{interactive} F
\>EpimorphismPqStandardPresentation( <G> : <options> )!{interactive} F
\>EpimorphismStandardPresentation( <i>, <p> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <p> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <i>, <G> : <options> )!{interactive} M
\>EpimorphismStandardPresentation( <G> : <options> )!{interactive} M

Each of the above functions accepts the same arguments and options as the
function `StandardPresentation' (see~"StandardPresentation") and  returns
an epimorphism from the finitely presented group  <F>  of  the  <i>th  or
default interactive {\ANUPQ} process onto the  finitely  presented  group
given  by  a  standard  presentation,  i.e.~if  <S>   is   the   standard
presentation   computed   for   <F>   by   `StandardPresentation'    then
`EpimorphismStandardPresentation' returns the epimorphism from <F> to the
group with presentation <S>. The group <F> is the group  given  as  first
argument  to  `PqStart'  to  start  the  interactive   {\ANUPQ}   process
(see~"PqStart").

Taking        our         earlier         non-interactive         example
(see~"EpimorphismPqStandardPresentation")   we   again   illustrate   how
something that required two separate calls to the `pq' binary can now  be
achieved with a dialogue with just one `pq' process.

\beginexample
gap> F := FreeGroup(6);;
gap> x := F.1;; y := F.2;; z := F.3;; w := F.4;; a := F.5;; b := F.6;;
gap> R := [x^3 / w, y^3 / w * a^2 * b^2, w^3 / b,
>          Comm (y, x) / z, Comm (z, x), Comm (z, y) / a, z^3 ];;
gap> Q := F / R;;
gap> PqStart(Q); #Start a new interactive process for a new group       
3
gap> G := Pq( 3 : Prime := 3, ClassBound := 3 );
<pc group of size 729 with 6 generators>
gap> phi := EpimorphismStandardPresentation( 3, 3 : ClassBound := 3 );
[ f1, f2, f3, f4, f5, f6 ] -> [ f1*f2^2*f3*f4^2*f5^2, f1*f2*f3*f5, f3^2, 
  f4*f6^2, f5, f6 ]
gap> Size( Image(phi) );
729
\endexample

\>PqDescendants( <i> : <options> )!{interactive} F
\>PqDescendants( : <options> )!{interactive} F

returns for the the pc-group <G>, of the  <i>th  or  default  interactive
{\ANUPQ} process, which must be of prime power  order  with  a  confluent
pc-presentation  (see~"ref:IsConfluent!for  pc  groups"),   a   list   of
descendants (pc groups) of <G>. The group <G> is the group given as first
argument  to  `PqStart'  to  start  the  interactive   {\ANUPQ}   process
(see~"PqStart"). Following the colon <options> a selection of the options
listed    for    the     non-interactive     `PqDescendants'     function
(see~"PqDescendants") should be given, separated by  commas  like  record
components  (see~"ref:function  call  with  options"),  except  that  the
options `SetupFile' or  `PqWorkspace'  are  ignored  by  the  interactive
`PqDescendants',  i.e.~the  following  options  are  recognised  by   the
interactive `PqDescendants' function:

\beginlist

\atindex{option ClassBound}{@option \noexpand`ClassBound'}
\item{}`ClassBound := <n>'

\atindex{option Relators}{@option \noexpand`Relators'}
\item{}`Relators := <rels>'

\atindex{option OrderBound}{@option \noexpand`OrderBound'}
\item{}`OrderBound := <n>'

\atindex{option StepSize}{@option \noexpand`StepSize'}
\item{}`StepSize := <nOrlist>'

\atindex{option PcgsAutomorphisms}{@option \noexpand`PcgsAutomorphisms'}
\item{}`PcgsAutomorphisms'

\atindex{option RankInitialSegmentSubgroups}%
{@option \noexpand`RankInitialSegmentSubgroups'}
\item{}`RankInitialSegmentSubgroups := <n>'

\atindex{option SpaceEfficient}{@option \noexpand`SpaceEfficient'}
\item{}`SpaceEfficient'

\atindex{option CapableDescendants}{@option \noexpand`CapableDescendants'}
\item{}`CapableDescendants'

\atindex{option AllDescendants}{@option \noexpand`AllDescendants'}
\item{}`AllDescendants := false'

\atindex{option Exponent}{@option \noexpand`Exponent'}
\item{}`Exponent := <n>'

\atindex{option Metabelian}{@option \noexpand`Metabelian'}
\item{}`Metabelian'

\atindex{option GroupName}{@option \noexpand`GroupName'}
\item{}`GroupName := <name>'

\atindex{option SubList}{@option \noexpand`SubList'}
\item{}`SubList := <sub>'

\atindex{option BasicAlgorithm}{@option \noexpand`BasicAlgorithm'}
\item{}`BasicAlgorithm'

\atindex{option TailorOutput}{@option \noexpand`TailorOutput'}
\item{}`TailorOutput := <rec>'

\endlist

Detailed descriptions of the above options may be found in Chapter~"ANUPQ
options".

If <G> does *not* have $p$-class 1, then the automorphism  group  of  <G>
must be known. In practice, the automorphism group  of  <G>  is  computed
using the {\GAP} command `AutomorphismGroup'. Note that the {\GAP}  share
package {\AutPGrp} provides an algorithm for computing  the  automorphism
group of a $p$-group which performs better than the  standard  method  in
{\GAP}.

If the automorphism group  of  <G>  is  not  soluble  or  if  the  option
`PcgsAutomorphisms' (see below) is not used, then the  `pq'  binary  will
call {\GAP} together with the {\AutPGrp}  package  as  a  subprocess  for
certain orbit-stabilizer calculations.

Let us now repeat the examples previously given for  the  non-interactive
`PqDescendants',  but  this  time  with  the   interactive   version   of
`PqDescendants':

\beginexample
gap> F := FreeGroup( "a", "b" );; a := F.1;; b := F.2;;
gap> G := PcGroupFpGroup( F / [ a^2, b^2, Comm(b, a) ] );
<pc group of size 4 with 2 generators>
gap> PqStart(G);
4
gap> #This is now the 4th interactive process running
gap> des := PqDescendants( 4 : OrderBound := 6, ClassBound := 5 );;
gap> Length(des);
83
gap> List(des, Size);
[ 8, 8, 8, 16, 16, 16, 32, 16, 16, 16, 16, 16, 32, 32, 64, 64, 32, 32, 32, 
  32, 32, 32, 32, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 32, 32, 32, 32, 
  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 32, 32, 32, 32, 32, 64, 64, 64, 
  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 
  64, 64, 64, 64, 64, 64, 64 ]
gap> List(des, d -> Length( PCentralSeries( d, 2 ) ) - 1 );
[ 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
  4, 4, 4, 5, 5, 5, 5, 5 ]
\endexample

In the second example we compute all  capable descendants of order  27 of
the  elementary abelian group of order 9.  

\beginexample
gap> F := FreeGroup( 2, "g" );;                                 
gap> G := PcGroupFpGroup( F / [ F.1^3, F.2^3, Comm(F.1, F.2) ] );
<pc group of size 9 with 2 generators>
gap> A := AutomorphismGroup( G );
<group with 4 generators>
gap> IsSolvable(A);
true
gap> Pcgs(A);
Pcgs([ [ g1, g2 ] -> [ g1, g2^2 ], [ g1, g2 ] -> [ g1, g1*g2 ], 
  [ g1, g2 ] -> [ g1^2*g2, g1*g2 ], [ g1, g2 ] -> [ g2^2, g1 ], 
  [ g1, g2 ] -> [ g1^2, g2^2 ] ])
gap> PqStart(G); #This will now be the 5th interactive process running
5
gap> des := PqDescendants( 5 : OrderBound := 3, ClassBound := 2,
>                              PcgsAutomorphisms, CapableDescendants );
[ <pc group of size 27 with 3 generators>, 
  <pc group of size 27 with 3 generators> ]
gap> List(des, d -> Length( PCentralSeries( d, 3 ) ) - 1 );
[ 2, 2 ]
\endexample

In  the  third  example,  we  compute  all  capable  descendants  of  the
elementary abelian group of order  $5^2$ which have exponent-$5$ class at
most $3$, exponent $5$, and are metabelian.

\beginexample
gap> F := FreeGroup( 2, "g" );;
gap> G := PcGroupFpGroup( F / [ F.1^5, F.2^5, Comm(F.2, F.1) ] );
<pc group of size 25 with 2 generators>
gap> PqStart(G); #This will now be the 6th interactive process running
6
gap> des := PqDescendants( 6 : Metabelian, ClassBound := 3,
>                              Exponent := 5, CapableDescendants );
[ <pc group of size 125 with 3 generators>, 
  <pc group of size 625 with 4 generators>, 
  <pc group of size 3125 with 5 generators> ]
gap> List(des, d -> Length( PCentralSeries( d, 5 ) ) - 1 );
[ 2, 3, 3 ]
gap> List(des, d -> Length( DerivedSeries( d ) ) );
[ 3, 3, 3 ]
gap> List(des, d -> Maximum( List( Elements(d), Order ) ) );
[ 5, 5, 5 ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Low-level Interactive ANUPQ Functions based on menu items of the
pq binary}

*WARNING!! MOST OF THE FOLLOWING FUNCTIONS HAVE FEW SAFEGUARDS ... WE'RE
 WORKING ON IT, BUT IT'S USE AT YOUR OWN RISK AT THE MOMENT ... IF YOU
 DON'T DEFINE A PC PRESENTATION BEFORE DOING CERTAIN COMMANDS, THE pq
 BINARY WILL PROBABLY DIE ON YOU*

The `pq' binary has 5 menus, the details of which  the  reader  will  not
normally need to know, but if she wishes to know the details they may  be
found in the standalone manual: `guide.dvi'.  Both  `guide.dvi'  and  the
`pq' binary refer to the items of these 5 menus as ``options'', which  do
*not* correspond in any way to the options used  by  any  of  the  {\GAP}
functions that interface with the `pq' binary.

*Main $p$-Quotient menu commands*

\>PqPcPresentation( <i> : <options> ) F
\>PqPcPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> for the group of  that  process  so  that  the  `pq'  binary
computes a pc presentation, where the group of a process is the one given
as first argument when `PqStart' was called to initiate that process (for
process <i> the group is stored as `ANUPQData.io[<i>].group').

The  possible  <options>  are  the  same  as  for  the  interactive  `Pq'
(see~"Pq!interactive")   function,   namely:    `Prime',    `ClassBound',
`Exponent', `Relators', `GroupName', `Metabelian' and `OutputLevel'  (see
Chapter~"ANUPQ options" for a detailed description  for  these  options).
The option `Prime' is required  unless  already  provided  to  `PqStart'.
Also, option `ClassBound' *must* be supplied.

*Note:* For those  familiar  with  the  `pq'  binary,  `PqPcPresentation'
performs option 1 of the main $p$-Quotient menu.

\>PqSavePcPresentation( <i>, <filename> ) F
\>PqSavePcPresentation( <filename> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to save the pc presentation previously computed for the  group  of
that process to the file with name  <filename>,  where  the  group  of  a
process is the one given as first argument when `PqStart' was  called  to
initiate that process. If the first character of the string <filename> is
not `/', <filename> is assumed to be the path of a writable file relative
to the directory in which {\GAP} was started.

*Note:* For those familiar with the `pq'  binary,  `PqSavePcPresentation'
performs option 2 of the main $p$-Quotient menu.

\>PqRestorePcPresentation( <i>, <filename> ) F
\>PqRestorePcPresentation( <filename> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to restore the pc presentation previously saved to <filename>  for
the group of that process, where the group of a process is the one  given
as first argument when `PqStart' was called to initiate that process.  If
the first character of the string <filename> is not  `/',  <filename>  is
assumed to be the path of a readable file relative to  the  directory  in
which {\GAP} was started.

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqRestorePcPresentation'
performs option 3 of the main $p$-Quotient menu.

\>PqFactoredOrder( <i> ) F
\>PqFactoredOrder() F

for the <i>th  or  default  interactive  {\ANUPQ}  process,  returns  the
factored order as a list `[<p>, <n>]' of the current class group  of  the
`pq' binary.

*Note:* The order of each $p$-class quotient is taken as $p^n$ where  $n$
is the number of generators for the class; this may be  an  over-estimate
if tails have been added and the necessary consistency  checks,  relation
collections, exponent law checks  and  redundant  generator  eliminations
have not been done for a class.

\>PqOrder( <i> ) F
\>PqOrder() F

for the <i>th or default interactive {\ANUPQ} process, returns the  order
of the current class group of the `pq' binary.

*Note:* The order of each $p$-class quotient is taken as $p^n$ where  $n$
is the number of generators for the class; this may be  an  over-estimate
if tails have been added and the necessary consistency  checks,  relation
collections, exponent law checks  and  redundant  generator  eliminations
have not been done for a class.

\>PqPClass( <i> ) F
\>PqPClass() F

for the <i>th  or  default  interactive  {\ANUPQ}  process,  returns  the
current lower exponent-$p$ class group of the `pq' binary.

\>PqNrPcGenerators( <i> ) F
\>PqNrPcGenerators() F

for the <i>th or default interactive {\ANUPQ} process, returns the number
of pc generators of the current exponent-$p$  class  group  of  the  `pq'
binary.

\>PqWeight( <i>, <j> ) F
\>PqWeight( <j> ) F

for the <i>th or default interactive {\ANUPQ} process, returns the weight
of the <j>th pc generator of the current exponent-$p$ class group of  the
`pq' binary, or `fail' if there is no such numbered pc generator.

\>PqCurrentGroup( <i> ) F
\>PqCurrentGroup() F

for the <i>th  or  default  interactive  {\ANUPQ}  process,  returns  the
current lower exponent $p$-class quotient of the group of the process  as
a pc group.

\>PqDisplayPcPresentation( <i> ) F
\>PqDisplayPcPresentation() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to display the pc presentation to the current class known  to  the
`pq' binary for the group of that process, where the group of  a  process
is the one given as first argument when `PqStart' was called to  initiate
that process. Except if the last  command  communicating  with  the  `pq'
binary was a $p$-group generation command (for  which  there  is  only  a
verbose output level), to set the  amount  of  information  this  command
displays   you   may    wish    to    call    `PqSetOutputLevel'    first
(see~"PqSetOutputLevel"), or equivalently pass the  option  `OutputLevel'
(see~"option OutputLevel").

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqDisplayPcPresentation'
performs option 4 of the current menu of the `pq' binary.

\>PqSetOutputLevel( <i>, <lev> ) F
\>PqSetOutputLevel( <lev> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to set the output level of the `pq' binary to <lev>.

*Note:* For those  familiar  with  the  `pq'  binary,  `PqSetOutputLevel'
performs option 5 of the main (or advanced)  $p$-Quotient  menu,  or  the
Standard Presentation menu.

\>PqNextClass( <i> ) F
\>PqNextClass() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
to calculate the next class of `ANUPQData.io[<i>].group'. 

\atindex{option QueueFactor}{@option \noexpand`QueueFactor'}
`PqNextClass'  accepts  the  option  `QueueFactor'  which  should  be   a
positive integer if automorphisms have been previously supplied.  If  the
`pq' binary requires a queue factor and none is supplied via  the  option
`QueueFactor' a default of 15 is taken.

*Note:* For those familiar with the `pq' binary,  `PqNextClass'  performs
option 6 of the main $p$-Quotient menu.

\>PqPCover( <i> ) F
\>PqPCover() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
to compute the $p$-covering group of `ANUPQData.io[<i>].group'.

*Note:* For those familiar with  the  `pq'  binary,  `PqPCover'  performs
option 7 of the main $p$-Quotient menu.

*Advanced $p$-Quotient menu commands*

\>PqCollect( <i>, <word> ) F
\>PqCollect( <word> ) F

for the <i>th or default interactive {\ANUPQ} process, instructs the `pq'
binary to do a collection on <word> a string representing the product  of
three generators, e.g. `"x3*x2*x1"'.

*Note:* For those familiar with the  `pq'  binary,  `PqCollect'  performs
option 1 of the Advanced $p$-Quotient menu.

\>PqSolveEquation( <i>, <a>, <b> ) F
\>PqSolveEquation( <a>, <b> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to solve $<a> * <x> = <b>$ for <x>. 

*Note:* 
For those familiar  with  the  `pq'  binary,  `PqSolveEquation'  performs
option 2 of the Advanced $p$-Quotient menu.

\>PqCommutator( <i>, <words>, <pow> ) F
\>PqCommutator( <words>, <pow> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute the left norm commutator of the list <words>  of  words
in the generators raised to the integer power <pow>.

*Note:*
For those familiar with the `pq' binary, `PqCommutator' performs option 3
of the Advanced $p$-Quotient menu.

\>PqSetupTablesForNextClass( <i> ) F
\>PqSetupTablesForNextClass() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to set up tables for the next class.

*Note:* 
For those familiar  with  the  `pq'  binary,  `PqSetupTablesForNextClass'
performs option 6 of the Advanced $p$-Quotient menu.

\>PqAddTails( <i>, <weight> ) F
\>PqAddTails( <weight> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to add tails of weight <weight>, where <weight> is a  non-negative
integer (a <weight> of `0' means all weights).

*Note:*
For those familiar with the `pq' binary, `PqAddTails' uses  option  7  of
the Advanced $p$-Quotient menu.

\>PqComputeTails( <i>, <weight> ) F
\>PqComputeTails( <weight> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary  to  compute  tails  of  weight  <weight>,  where  <weight>  is  a
non-negative integer (a <weight> of `0' means all weights).

*Note:*
For those familiar with the `pq' binary, `PqComputeTails' uses  option  7
of the Advanced $p$-Quotient menu.

\>PqTails( <i>, <weight> ) F
\>PqTails( <weight> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute and add tails of weight <weight>, where <weight>  is  a
non-negative integer (a <weight> of `0' means all weights).

*Note:*
For those familiar with the `pq' binary, `PqTails' uses option 7  of  the
Advanced $p$-Quotient menu.

\>PqDoConsistencyChecks( <i>, <weight>, <type> ) F
\>PqDoConsistencyChecks( <weight>, <type> ) F

for the <i>th or default interactive  {\ANUPQ}  process,  do  consistency
checks of type <type> for weight <weight>; <type> should be an integer in
`[0,1,2,3]' (`0' means do  *all*  checks),  and  <weight>  should  be  an
integer in `[0 .. <class>]' where <class> is the maximum class (`0' means
all weights).

*Note:*
For those familiar with the `pq' binary, `PqDoConsistencyChecks' performs
option 8 of the Advanced $p$-Quotient menu.

\>PqCollectDefiningRelations( <i> ) F
\>PqCollectDefiningRelations() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to collect defining relations.

*Note:*
For those familiar with  the  `pq'  binary,  `PqCollectDefiningRelations'
performs option 9 of the Advanced $p$-Quotient menu.

\>PqDoExponentChecks(<i>[: Bounds := <list>]) F
\>PqDoExponentChecks([: Bounds := <list>]) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to do exponent checks for weights (inclusively) between the bounds
of `Bounds' or for all weights if `Bounds' is not given. The value <list>
of `Bounds' (assuming the interactive process is numbered <i>) should  be
a list of  two  integers  <low>,  <high>  satisfying  $1  \le  <low>  \le
`PqPClass(<i>) + 1'$ (see~"PqPClass").

\>PqEliminateRedundantGenerators( <i> ) F
\>PqEliminateRedundantGenerators() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to eliminate redundant generators.

*Note:* 
For those familiar with the `pq' binary, `PqEliminateRedundantGenerators'
performs option 11 of the Advanced $p$-Quotient menu.

\>PqRevertToPreviousClass( <i> ) F
\>PqRevertToPreviousClass() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to abandon the current class and revert to the previous class.

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqRevertToPreviousClass'
performs option 12 of the Advanced $p$-Quotient menu.

\>PqSetMaximalOccurrences( <i>, <noccur> ) F
\>PqSetMaximalOccurrences( <noccur> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to set maximal occurrences of  the  weight  1  generators  in  the
definitions of pcp generators of the group of the process; <noccur>  must
be a list of non-negative integers of  length  the  number  of  weight  1
generators (i.e.~the rank of the class 1 $p$-quotient of the group of the
process). An entry of `0' for a particular generator indicates that there
is no limit on the number of occurrences for the generator.

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqSetMaximalOccurrences'
performs option 13 of the Advanced $p$-Quotient menu.

\>PqSetMetabelian( <i> ) F
\>PqSetMetabelian() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to enforce metabelian-ness.

*Note:* 
For those familiar  with  the  `pq'  binary,  `PqSetMetabelian'  performs
option 14 of the Advanced $p$-Quotient menu.

\>PqDoConsistencyCheck( <i>, <c>, <b>, <a> ) F
\>PqDoConsistencyCheck( <c>, <b>, <a> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to do a consistency check; the generator  indices  <c>,  <b>,  <a>
should be non-increasing positive integers, i.e.~$<c> \ge <b> \ge <a>$.

*Note:*
For those familiar with the `pq' binary, `PqDoConsistencyCheck'  performs
option 15 of the Advanced $p$-Quotient menu.

\>PqCompact( <i> ) F
\>PqCompact() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to do a compaction.

*Note:*
For those familiar with the `pq' binary, `PqCompact' performs  option  16
of the Advanced $p$-Quotient menu.

\>PqEchelonise( <i> ) F
\>PqEchelonise() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to echelonise relation. A call to `PqCollect' (see~"PqCollect") or
`PqCommutator' needs to be performed prior to using this command.

*Note:*
For those familiar with the `pq' binary, `PqEchelonise'  performs  option
17 of the Advanced $p$-Quotient menu.

\>PqSupplyAutomorphisms( <i>, <mlist> ) F
\>PqSupplyAutomorphisms( <mlist> ) F

for the <i>th or  default  interactive  {\ANUPQ}  process,  supplies  the
automorphism  data  provided  by  the  list  <mlist>  of  matrices   with
non-negative integer coefficients. Each matrix in <mlist> must  have  the
same dimensions; in particular, the number of rows of each matrix must be
the rank of the $p$-quotient of the group associated with the interactive
{\ANUPQ} process.

*Note:* 
For those familiar with the  `pq'  binary,  `PqSupplyAutomorphisms'  uses
option 18 of the Advanced $p$-Quotient menu.

\>PqExtendAutomorphisms( <i> ) F
\>PqExtendAutomorphisms() F

for the <i>th or default interactive {\ANUPQ} process, inputs data to the
`pq' binary to extend previously-supplied automorphisms.

*Note:*
For those familiar with the  `pq'  binary,  `PqExtendAutomorphisms'  uses
option 18 of the Advanced $p$-Quotient menu.

\>PqApplyAutomorphisms( <i>, <qfac> ) F
\>PqApplyAutomorphisms( <qfac> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to apply automorphisms; <qfac> is the queue factor e.g. `15'.

*Note:* 
For those familiar with  the  `pq'  binary,  `PqCloseRelations'  performs
option 19 of the Advanced $p$-Quotient menu.

\>PqDisplayStructure(<i>[: Bounds := <list>]) F
\>PqDisplayStructure([: Bounds := <list>]) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary  to  display  the  structure  for  the  pcp  generators   numbered
(inclusively) between the bounds of `Bounds' or  for  all  generators  if
`Bounds' is not  given.  The  value  <list>  of  `Bounds'  (assuming  the
interactive process is numbered <i>) should be a  list  of  two  integers
<low>,  <high>  satisfying  $1  \le  <low>  \le  `PqNrPcGenerators(<i>)'$
(see~"PqNrPcGenerators"). `PqDisplayStructure' also  accepts  the  option
`OutputLevel' (see "option OutputLevel").

*Note:*
For those familiar with the `pq'  binary,  `PqDisplayStructure'  performs
option 20 of the Advanced $p$-Quotient menu.

\>PqDisplayAutomorphisms(<i>[: Bounds := <list>]) F
\>PqDisplayAutomorphisms([: Bounds := <list>]) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to display the  automorphisms  for  the  pcp  generators  numbered
(inclusively) between the bounds of `Bounds' or  for  all  generators  if
`Bounds' is not  given.  The  value  <list>  of  `Bounds'  (assuming  the
interactive process is numbered <i>) should be a  list  of  two  integers
<low>,  <high>  satisfying  $1  \le  <low>  \le  `PqNrPcGenerators(<i>)'$
(see~"PqNrPcGenerators"). `PqDisplayStructure' also  accepts  the  option
`OutputLevel' (see "option OutputLevel").

*Note:*
For  those  familiar  with  the  `pq'  binary,   `PqDisplayAutomorphisms'
performs option 21 of the Advanced $p$-Quotient menu.

\>PqCollectDefiningGenerators( <i>, <word> ) F
\>PqCollectDefiningGenerators( <word> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to do a collection on <word> a string representing the product  of
three generators, e.g. `"x3*x2*x1"'.

*Note:*
For those familiar with the  `pq'  binary,  `PqCollectDefiningGenerators'
performs option 23 of the Advanced $p$-Quotient menu.

\>PqCommutatorDefiningGenerators( <i>, <words>, <pow> ) F
\>PqCommutatorDefiningGenerators( <words>, <pow> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute the left norm commutator of the list <words>  of  words
in the generators raised to the integer power <pow>.

*Note:*
For those familiar with the `pq' binary, `PqCommutatorDefiningGenerators'
performs option 24 of the Advanced $p$-Quotient menu.

\>PqWritePcPresentation( <i>, <filename> ) F
\>PqWritePcPresentation( <filename> ) F

for the <i>th or default interactive {\ANUPQ}  process,  tells  the  `pq'
binary to write a pc presentation to the file with  name  <filename>  for
the group of that process for which a pc presentation has been previously
computed, where the group of a process is the one given as first argument
when `PqStart' was called to initiate that process (for process  <i>  the
group is stored as `ANUPQData.io[<i>].group'). If the first character  of
the string <filename> is not `/', <filename> is assumed to be the path of
a writable file relative to the directory in which {\GAP} was started. If
a pc presentation has not been previously computed by  the  `pq'  binary,
then  `pq'  is  called  to  compute  it   first,   effectively   invoking
`PqPcPresentation' (see~"PqPcPresentation").

*Note:* For those familiar with the `pq' binary,  `PqPcWritePresentation'
performs option 25 of the Advanced $p$-Quotient menu.

\>PqWriteCompactDescription( <i> ) F
\>PqWriteCompactDescription() F

for the <i>th or default interactive {\ANUPQ}  process,  tells  the  `pq'
binary to write a compact description to a file.

*Note:* 
For those familiar  with  the  `pq'  binary,  `PqWriteCompactDescription'
performs option 26 of the Advanced $p$-Quotient menu.

*Main $p$-Group Generation menu commands*

\>PqPGSupplyAutomorphisms( <i>[, <mlist>] ) F
\>PqPGSupplyAutomorphisms([<mlist>]) F

for the <i>th or default interactive {\ANUPQ} process,  supply  the  `pq'
binary with the automorphism group data needed  for  the  group  of  that
process    (for    process    <i>    the    group    is     stored     as
`ANUPQData.io[<i>].group'). If  the  argument  <mlist>  is  omitted  then
{\GAP} *must* be able to determine the automorphism group of the group of
the process. Otherwise the automorphism data  is  provided  from  <mlist>
which  should  be  a  list  of   matrices   with   non-negative   integer
coefficients, where  each  matrix  must  have  the  same  dimensions;  in
particular, the number of rows of each matrix must be  the  rank  of  the
group of the process.

*Note:*
For  those  familiar  with  the  `pq'  binary,  `PqPGSupplyAutomorphisms'
performs option 1 of the main $p$-Group Generation menu.

\>PqPGExtendAutomorphisms( <i> ) F
\>PqPGExtendAutomorphisms() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute the extensions of the automorphisms defined by  calling
`PqPGSupplyAutomorphisms' (see~"PqPGSupplyAutomorphisms"). You  may  wish
to set the `InfoLevel' of `InfoANUPQ' to 2 (or more) in order to see  the
output from the `pq' (see~"InfoANUPQ").

*Note:*    
For  those  familiar  with  the  `pq'  binary,  `PqPGExtendAutomorphisms'
performs option 2 of the main $p$-Group Generation menu. 

\>PqPGRestoreGroupFromFile( <i>, <cls>, <n> ) F
\>PqPGRestoreGroupFromFile( <cls>, <n> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to restore group <n> of class <cls> from a temporary  file,  where
<cls> and <n> are positive integers.

*Note:* 
For those  familiar  with  the  `pq'  binary,  `PqPGRestoreGroupFromFile'
performs option 3 of the main $p$-Group Generation menu.

\>PqPGConstructDescendants( <i> : <options> ) F
\>PqPGConstructDescendants( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> to the `pq' binary to  construct  descendants.  The  options
possible are the same as those listed for the interactive `PqDescendants'
(see~"PqDescendants!interactive")   function,    namely:    `ClassBound',
`Relators',      `OrderBound',      `StepSize',      `PcgsAutomorphisms',
`RankInitialSegmentSubgroups',  `SpaceEfficient',   `CapableDescendants',
`AllDescendants',  `Exponent',  `Metabelian',   `GroupName',   `SubList',
`BasicAlgorithm', `TailorOutput'. (Detailed descriptions of these options
may be found in Chapter~"ANUPQ options".)

`PqPGConstructDescendants' requires that the `pq' binary  has  previously
computed a pc presentation and a $p$-cover for the group of the process.

*Note:* 
For those  familiar  with  the  `pq'  binary,  `PqPGConstructDescendants'
performs option 5 of the main $p$-Group Generation menu.

*Advanced $p$-Group Generation menu commands*

\>PqAPGSupplyAutomorphisms( <i>[, <mlist>] ) F
\>PqAPGSupplyAutomorphisms([<mlist>]) F

for the <i>th or default interactive {\ANUPQ} process,  supply  the  `pq'
binary with the automorphism group data needed  for  the  group  of  that
process    (for    process    <i>    the    group    is     stored     as
`ANUPQData.io[<i>].group'). If  the  argument  <mlist>  is  omitted  then
{\GAP} *must* be able to determine the automorphism group of the group of
the process. Otherwise the automorphism data  is  provided  from  <mlist>
which  should  be  a  list  of   matrices   with   non-negative   integer
coefficients, where  each  matrix  must  have  the  same  dimensions;  in
particular, the number of rows of each matrix must be  the  rank  of  the
group of the process.

*Note:*
For those  familiar  with  the  `pq'  binary,  `PqAPGSupplyAutomorphisms'
performs option 1 of the Advanced $p$-Group Generation menu.

\>PqAPGExtendAutomorphisms( <i> ) F
\>PqAPGExtendAutomorphisms() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute the extensions of the automorphisms defined by  calling
`PqAPGSupplyAutomorphisms' (see~"PqAPGSupplyAutomorphisms"). You may wish
to set the `InfoLevel' of `InfoANUPQ' to 2 (or more) in order to see  the
output from the `pq' (see~"InfoANUPQ").

*Note:*
For  those  familiar  with  the  `pq'  binary, `PqAPGExtendAutomorphisms'
performs option 2 of the Advanced $p$-Group Generation menu.

\>PqAPGRestoreGroupFromFile( <i>, <cls>, <n> ) F
\>PqAPGRestoreGroupFromFile( <cls>, <n> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to restore group <n> of class <cls> from a temporary  file,  where
<cls> and <n> are positive integers.

*Note:*
For those familiar  with  the  `pq'  binary,  `PqAPGRestoreGroupFromFile'
performs option 3 of the Advanced $p$-Group Generation menu.

*Standard Presentation menu commands*

\>PqSPPcPresentation( <i> : <options> ) F
\>PqSPPcPresentation( : <options> ) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> for the group of  that  process  so  that  the  `pq'  binary
computes a pc presentation, where the group of a process is the one given
as first argument when `PqStart' was called to initiate that process (for
process <i> the group is stored as `ANUPQData.io[<i>].group').

The  possible  <options>  are  the  same  as  for  the  interactive  `Pq'
(see~"Pq!interactive")   function,   namely:    `Prime',    `ClassBound',
`Exponent', `Relators', `GroupName', `Metabelian' and `OutputLevel'  (see
Chapter~"ANUPQ options" for details of these options). The option `Prime'
is  required  unless  already  provided  to   `PqStart'.   Also,   option
`ClassBound' *must* be supplied.

*Note:* For those familiar with  the  `pq'  binary,  `PqSPPcPresentation'
performs option 1 of the Standard Presentation menu.

\>PqSPStandardPresentation( <i>[, <mlist>][: <options>]) F
\>PqSPStandardPresentation( [<mlist>][: <options>]) F

for the <i>th or default interactive {\ANUPQ} process, inputs data  given
by <options> to compute a standard presentation for  the  group  of  that
process.  If  argument  <mlist>  is  given  it  is  assumed  to  be   the
automorphism group data required. Otherwise it is assumed that a call  to
either      `Pq'      (see~"Pq!interactive")      or      `PqEpimorphism'
(see~"PqEpimorphism!interactive") has generated a $p$-quotient  and  that
{\GAP} can compute  its  automorphism  group  from  which  the  necessary
automorphism group data can be derived. The group of the process  is  the
one given as first argument when `PqStart' was  called  to  initiate  the
process (for process <i> the group is stored as `ANUPQData.io[<i>].group'
and     the     $p$-quotient     if     existent     is     stored     as
`ANUPQData.io[<i>].pQuotient').  If  <mlist>   is   not   given   and   a
$p$-quotient of the group has not been  previously  computed  a  class  1
$p$-quotient is computed.

`PqSPStandardPresentation' accepts three options, all optional:

\beginlist

\atindex{option ClassBound}{@option \noexpand`ClassBound'}
\item{}`ClassBound := <n>'

\atindex{option PcgsAutomorphisms}{@option \noexpand`PcgsAutomorphisms'}
\item{}`PcgsAutomorphisms'

\atindex{option StandardPresentationFile}%
{@option \noexpand`StandardPresentationFile'}
\item{}`StandardPresentationFile := <filename>'

\endlist

Detailed descriptions of the above options may be found in Chapter~"ANUPQ
options".

*Note:* For those familiar with  the  `pq'  binary,  `PqSPPcPresentation'
performs option 2 of the Standard Presentation menu.

\>PqSPSavePresentation( <i>, <filename> ) F
\>PqSPSavePresentation( <filename> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to save the standard  presentation  previously  computed  for  the
group of that process to the file with name <filename>, where  the  group
of a process is the one given as first argument when `PqStart' was called
to initiate that process. If the first character of the string <filename>
is not `/', <filename> is assumed to be  the  path  of  a  writable  file
relative to the directory in which {\GAP} was started.

*Note:* For those familiar with the `pq'  binary,  `PqSPSavePresentation'
performs option 3 of the Standard Presentation menu.

\>PqSPCompareTwoFilePresentations( <i>, <f1>, <f2> ) F
\>PqSPCompareTwoFilePresentations( <f1>, <f2> ) F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compare the presentations in the files with names <f1> and <f2>
and returns `true' if they are identical and `false' otherwise. For  each
of the strings <f1> and <f2>, if the first character is not a `/' then it
is assumed to be the path of a readable file relative to the directory in
which {\GAP} was started.

*Notes*

The presentations in files <f1> and <f2> must have been generated by  the
`pq' binary but they do *not* need to be *standard* presentations.

For      those      familiar      with      the       `pq'       binary,
`PqSPCompareTwoFilePresentations' performs  option  6  of  the  Standard
Presentation menu.

\>PqSPIsomorphism( <i> ) F
\>PqSPIsomorphism() F

for the <i>th or default interactive {\ANUPQ} process, directs  the  `pq'
binary to compute the isomorphism from the generators of the automorphism
group of `ANUPQData.io[<i>].pQuotient' to the generators for the standard
presentation.

*Note:* For  those  familiar  with  the  `pq'  binary,  `PqSPIsomorphism'
performs option 8 of the Standard Presentation menu.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Primitive Interactive ANUPQ Process Read/Write Functions}

For those familiar with using the `pq' binary as a standalone we  provide
primitive read/write tools to communicate directly  with  an  interactive
{\ANUPQ} process, started via `PqStart'. For the most part, it is  up  to
the user to translate the output strings from `pq'  binary  into  a  form
useful in {\GAP}.

\>PqRead( <i> ) F
\>PqRead() F

read a complete line of  {\ANUPQ}  output,  from  the  <i>th  or  default
interactive {\ANUPQ} process, if there is output to be read  and  returns
`fail' otherwise. When successful, the  line  is  returned  as  a  string
complete with trailing newline, colon, or question-mark character. Please
note that it is possible to be ``too  quick''  (i.e.~the  return  can  be
`fail' purely because the output from {\ANUPQ} is not there yet), but  if
`PqRead' finds any output at all, it waits for a complete line.  `PqRead'
also writes the line read via `Info' at `InfoANUPQ' level 2.  It  doesn't
try to distinguish banner and menu output from other output of  the  `pq'
binary.

\>PqReadAll( <i> ) F
\>PqReadAll() F

read and return as many *complete* lines of  {\ANUPQ}  output,  from  the
<i>th or default interactive {\ANUPQ} process, as there are to  be  read,
*at the time of the call*,  as  a  list  of  strings  with  any  trailing
newlines removed and returns the empty list otherwise.  `PqReadAll'  also
writes each line read via `Info' at `InfoANUPQ' level 2. It  doesn't  try
to distinguish banner and menu output  from  other  output  of  the  `pq'
binary. Whenever `PqReadAll' finds only a partial line, it waits for  the
complete line, thus increasing the probability that it has  captured  all
the output to be had from {\ANUPQ}.

\>PqReadUntil( <i>, <IsMyLine> ) F
\>PqReadUntil( <IsMyLine> ) F
\>PqReadUntil( <i>, <IsMyLine>, <Modify> ) F
\>PqReadUntil( <IsMyLine>, <Modify> ) F

read complete lines  of  {\ANUPQ}  output,  from  the  <i>th  or  default
interactive {\ANUPQ} process, ``chomps'' them (i.e.~removes any  trailing
newline character), emits them to `Info' at `InfoANUPQ' level 2  (without
trying to distinguish banner and menu output from  other  output  of  the
`pq' binary), and applies the function <Modify> (where <Modify>  is  just
the identity map/function for the first two forms)  until  a  ``chomped''
line  <line>  for  which  `<IsMyLine>(  <Modify>(<line>)  )'   is   true.
`PqReadUntil' returns the list of <Modify>-ed ``chomped'' lines read.

*Notes:* 
When provided by the user, <Modify> should be a function that  accepts  a
single string argument.

<IsMyLine> should be a function that is able  to  accept  the  output  of
<Modify> (or take a single string argument when <Modify> is not provided)
and should return a boolean.

If `<IsMyLine>( <Modify>(<line>) )' is  never  true,  `PqReadUntil'  will
wait indefinitely.

\>PqWrite( <i>, <string> ) F
\>PqWrite( <string> ) F

write <string> to the <i>th  or  default  interactive  {\ANUPQ}  process;
<string> must be in exactly the form the {\ANUPQ} standalone expects. The
command is echoed via `Info' at `InfoANUPQ' level 3 (with a  ```ToPQ> '''
prompt); i.e.~do `SetInfoLevel(InfoANUPQ, 3);' to see what is transmitted
to the `pq' binary. `PqWrite' returns `true' if successful in writing  to
the stream of the interactive {\ANUPQ} process, and `fail' otherwise.

*Note:*
If `PqWrite' returns `fail' it means that the {\ANUPQ} process has died.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%E
